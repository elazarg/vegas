// Two-robot corridor: robots declare courtesy and choose entry times; collisions and yielding decide payoffs.
// Payoff structure: earlier entry earns bonus, collisions require yielding, timeouts incur penalties.

type time = {0, 1, 2}

game main() {
  join R1() $ 100 R2() $ 100;

  yield R1(courteous: bool) R2(courteous: bool);
  yield R1(t: time) R2(t: time);

  withdraw
    // Handle quit cases
    (R1.courteous == null || R1.t == null) && (R2.courteous == null || R2.t == null) ?
      { R1 -> 100; R2 -> 100; }  // Both quit: return deposits
    : (R1.courteous == null || R1.t == null) ?
      { R1 -> 50; R2 -> 150; }  // R1 quit: penalized
    : (R2.courteous == null || R2.t == null) ?
      { R1 -> 150; R2 -> 50; }  // R2 quit: penalized

    // Handle collision-free entry
    : (R1.t != R2.t) ?
      { R1 -> 100 + (10 - R1.t) * 10; R2 -> 100 + (10 - R2.t) * 10; }  // Earlier entry bonus

    // Handle collisions based on courtesy
    : (!R1.courteous && !R2.courteous) ?
      { R1 -> 50; R2 -> 50; }  // Stubborn collision: both penalized
    : (R1.courteous && !R2.courteous) ?
      { R1 -> (R1.t + 1 <= 2) ? (100 + (10 - (R1.t + 1)) * 10) : 100;
        R2 -> 100 + (10 - R2.t) * 10; }  // R1 yields, delayed entry
    : (!R1.courteous && R2.courteous) ?
      { R1 -> 100 + (10 - R1.t) * 10;
        R2 -> (R2.t + 1 <= 2) ? (100 + (10 - (R2.t + 1)) * 10) : 100; }  // R2 yields, delayed entry
    : { R1 -> (R1.t + 1 <= 2) ? (100 + (10 - (R1.t + 1)) * 10) : 100;
        R2 -> (R2.t + 1 <= 2) ? (100 + (10 - (R2.t + 1)) * 10) : 100; }  // Both courteous: both yield
}
