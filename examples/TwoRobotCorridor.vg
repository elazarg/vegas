// Two-robot corridor: robots declare courtesy and choose entry times; collisions and yielding decide payoffs.
// Distribution semantics: pot (200 wei) - earlier entry and courtesy affect allocation

type time = {0, 1, 2}

macro robotPayoff(myTime: time, otherTime: time, myCourteous: bool, otherCourteous: bool): int =
    (myTime != otherTime) ? (100 + (10 - myTime) * 10)  // Earlier entry gets bonus
  : (!myCourteous && !otherCourteous) ? 50  // Collision with no courtesy
  : (myCourteous && !otherCourteous) ? ((myTime + 1 <= 2) ? (100 + (10 - (myTime + 1)) * 10) : 100)  // Yield and retry
  : (!myCourteous && otherCourteous) ?  (100 + (10 - myTime) * 10)  // Benefit from other's courtesy
  : ((myTime + 1 <= 2) ? (100 + (10 - (myTime + 1)) * 10) : 100);  // Both courteous

game main() {
  join R1() $ 100 R2() $ 100;
  
  yield R1(courteous: bool) R2(courteous: bool);

  yield R1(t: time) R2(t: time);

  withdraw (R1.courteous == null || R1.t == null) && (R2.courteous == null || R2.t == null) ?
      { R1 -> 100; R2 -> 100; }  // Both quit at some point
    : (R1.courteous == null || R1.t == null) ?
      { R1 -> 50; R2 -> 150; }  // R1 quit
    : (R2.courteous == null || R2.t == null) ?
      { R1 -> 150; R2 -> 50; }  // R2 quit
    : {
      R1 -> robotPayoff(R1.t, R2.t, R1.courteous, R2.courteous);
      R2 -> robotPayoff(R2.t, R1.t, R2.courteous, R1.courteous);
    }
}
