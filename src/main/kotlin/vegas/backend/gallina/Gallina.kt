package vegas.backend.gallina

import vegas.FieldRef
import vegas.RoleId
import vegas.VarId
import vegas.dag.Algo
import vegas.ir.*

enum class LivenessPolicy {
    /**
     * Strict/Idealized.
     * Assumes every action in the DAG is played successfully.
     * No wrappers. Direct dependencies.
     */
    FAIR_PLAY,

    /**
     * Propagated Failure with Monotonicity.
     * Actions are wrapped in `UnlessQuit`.
     * Enforces Monotonicity: A player cannot act if they previously Quit.
     * Uses `getHave` for safe self-access.
     */
    MONOTONIC,

    /**
     * Sparse/Independent.
     * Actions are wrapped in `Maybe` (Present/Absent).
     * No structural monotonicity enforcement.
     * Strict data guards using pattern matching.
     */
    INDEPENDENT
}

class CoqDagEncoder(private val dag: ActionDag, private val policy: LivenessPolicy) {

    // 1. Topological Sort
    private val sortedIds: List<ActionId> by lazy {
        val adjacency = dag.actions.associateWith { dag.prerequisitesOf(it) }
        Algo.topo(dag.actions, adjacency)
    }

    private val idToIndex: Map<ActionId, Int> by lazy {
        sortedIds.withIndex().associate { it.value to it.index }
    }

    // 2. Transitive Ancestors Cache
    private val ancestors: Map<Int, List<Int>> by lazy {
        val map = mutableMapOf<Int, List<Int>>()
        for (i in sortedIds.indices) {
            val id = sortedIds[i]
            val paramAncestors = dag.reach.ancestorsOf(id)
                .map { idToIndex[it]!! }
                .sorted()
            map[i] = paramAncestors
        }
        map
    }

    // 3. Field Writers
    private val fieldWriter: Map<FieldRef, Int> by lazy {
        val map = mutableMapOf<FieldRef, Int>()
        for (id in dag.actions) {
            val struct = dag.meta(id).struct
            for ((field, vis) in struct.visibility) {
                if (vis == Visibility.PUBLIC || vis == Visibility.REVEAL) {
                    map[field] = idToIndex[id]!!
                }
            }
        }
        map
    }

    // Map SetTypes to IDs
    private val setTypeMap: Map<Type.SetType, Int> by lazy {
        var counter = 0
        val map = mutableMapOf<Type.SetType, Int>()
        for (meta in dag.metas) {
            for (p in meta.spec.params) {
                if (p.type is Type.SetType && !map.containsKey(p.type)) {
                    map[p.type] = counter++
                }
            }
        }
        map
    }

    // --- Generation Entry Point ---

    fun generate(): String = buildString {
        appendPreamble()
        appendRoles()
        appendQuitLogic()
        appendDomainDefinitions()

        appendLine("Module GameProtocol.")
        appendLine()

        // 1. Witnesses
        sortedIds.forEachIndexed { index, id ->
            generateWitnessRecord(this, index, dag.meta(id))
        }

        // 2. Execution Records
        when (policy) {
            LivenessPolicy.FAIR_PLAY -> {
                // Fair Play only generates the Run
                appendFairPlayRun(this)
            }
            LivenessPolicy.MONOTONIC -> {
                // Monotonic generates both the Fair Play Run (proof of possibility) AND the Execution (trace)
                appendFairPlayRun(this)
                appendExecutionRecord(this)
            }
            LivenessPolicy.INDEPENDENT -> {
                // Independent only generates the Execution trace
                appendExecutionRecord(this)
            }
        }

        appendLine("End GameProtocol.")
    }

    // --- Preamble & Helpers ---

    private fun StringBuilder.appendPreamble() {
        appendLine("(* Generated by Vegas Coq Encoder - Policy: $policy *)")
        appendLine("From Coq Require Import Bool.Bool.")
        appendLine("From Coq Require Import ZArith.ZArith.")
        appendLine("From Coq Require Import String.")
        appendLine()
        appendLine("Set Implicit Arguments.")
        appendLine("Set Primitive Projections.")
        appendLine()
        appendLine("Definition Hidden (A : Type) : Type := { x : A & unit }.")
        appendLine("Definition reveal {A} (h : Hidden A) : A := projT1 h.")
        appendLine()
    }

    private fun StringBuilder.appendRoles() {
        val roles = dag.actions.map { it.first }.distinct().sortedBy { it.name }
        append("Inductive Role : Type :=")
        if (roles.isEmpty()) append(" | Role_None")
        else roles.forEach { append(" | ${it.name}") }
        appendLine(".")
        appendLine()
    }

    private fun StringBuilder.appendQuitLogic() {
        if (policy == LivenessPolicy.FAIR_PLAY) return

        appendLine("(* --- Liveness Primitives --- *)")

        val failureName = if (policy == LivenessPolicy.INDEPENDENT) "Absence" else "QuitW"
        val wrapperName = if (policy == LivenessPolicy.INDEPENDENT) "Maybe" else "UnlessQuit"
        val presentName = if (policy == LivenessPolicy.INDEPENDENT) "Present" else "Have"
        val absentName  = if (policy == LivenessPolicy.INDEPENDENT) "Absent" else "Quit"

        appendLine("Inductive $failureName (r : Role) : Type := | Timeout : $failureName r.")
        appendLine()
        appendLine("Inductive $wrapperName (r : Role) (A : Type) : Type :=")
        appendLine("| $presentName : A -> $wrapperName r A")
        appendLine("| $absentName : $failureName r -> $wrapperName r A.")
        appendLine()
        appendLine("Arguments $presentName {r} {A} _.")
        appendLine("Arguments $absentName {r} {A} _.")
        appendLine()

        if (policy == LivenessPolicy.MONOTONIC) {
            appendLine("Definition IsHave {r A} (u : $wrapperName r A) : Prop :=")
            appendLine("  match u with $presentName _ => True | $absentName _ => False end.")
            appendLine()
            appendLine("Definition getHave {r A} (u : $wrapperName r A) : IsHave u -> A :=")
            appendLine("  match u with $presentName a => fun _ => a | $absentName _ => fun H => match H with end end.")
            appendLine()
        }
    }

    private fun StringBuilder.appendDomainDefinitions() {
        if (setTypeMap.isEmpty()) return
        appendLine("(* --- Domain Constraints --- *)")
        setTypeMap.toSortedMap(compareBy { it.values.toString() }).forEach { (type, id) ->
            val domainName = "domain_Enum_$id"
            append("Definition $domainName (z : Z) : Prop :=")
            if (type.values.isEmpty()) append(" False.")
            else {
                val disjunction = type.values.sorted().joinToString(" \\/ ") { v -> "z = $v%Z" }
                appendLine()
                appendLine("  $disjunction.")
            }
        }
        appendLine()
    }

    private fun paramName(f: FieldRef, hidden: Boolean) =
        if (hidden) VarId("hidden_${f.param}_${f.owner}")
        else VarId("${f.param}_${f.owner}")

    // --- Witness Generation ---

    private fun generateWitnessRecord(sb: StringBuilder, index: Int, meta: ActionMeta) {
        val myAncestors = ancestors[index] ?: emptyList()
        val myRole = meta.struct.owner

        sb.append("Record W$index")

        // 1. Dependencies
        if (myAncestors.isNotEmpty()) {
            sb.appendLine()
            for (ancIndex in myAncestors) {
                val ancId = sortedIds[ancIndex]
                val ancRole = dag.owner(ancId)
                val ancAncestors = ancestors[ancIndex] ?: emptyList()
                val appArgs = ancAncestors.joinToString(" ") { "w$it" }

                // Construct Type
                val rawType = if (appArgs.isEmpty()) "@W$ancIndex" else "@W$ancIndex $appArgs"

                // Wrap based on policy
                val finalType = when (policy) {
                    LivenessPolicy.FAIR_PLAY -> rawType
                    LivenessPolicy.MONOTONIC -> "UnlessQuit ${ancRole.name} ($rawType)"
                    LivenessPolicy.INDEPENDENT -> "Maybe ${ancRole.name} ($rawType)"
                }

                sb.append("  (w$ancIndex : $finalType)")
                sb.appendLine()
            }
        }
        sb.appendLine(" : Type := {")

        // 2. Data Parameters
        for (param in meta.spec.params) {
            val fieldRef = FieldRef(myRole, param.name)
            val vis = meta.struct.visibility[fieldRef] ?: Visibility.PUBLIC
            val isCommit = (vis == Visibility.COMMIT)
            val typeStr = toCoqType(param.type)
            val name = paramName(fieldRef, isCommit)

            if (isCommit) sb.appendLine("  $name : Hidden $typeStr;")
            else sb.appendLine("  $name : $typeStr;")
        }

        // --- 3. Guards ---

        // A. Monotonicity (Only MONOTONIC policy)
        if (policy == LivenessPolicy.MONOTONIC) {
            val selfDeps = myAncestors.filter { dag.owner(sortedIds[it]) == myRole }
            if (selfDeps.isNotEmpty()) {
                val checks = selfDeps.joinToString(" /\\ ") { "IsHave w$it" }
                sb.appendLine("  guard_monotonicity$index : $checks;")
            }
        }

        // B. Domain Constraints
        val domainChecks = meta.spec.params.filter { it.type is Type.SetType }.map { param ->
            val typeId = setTypeMap[param.type]!!
            val domainName = "domain_Enum_$typeId"
            val fieldRef = FieldRef(myRole, param.name)
            val isCommit = (meta.struct.visibility[fieldRef] == Visibility.COMMIT)
            val varName = paramName(fieldRef, isCommit).name
            val valExpr = if (isCommit) "(reveal $varName)" else varName
            "$domainName $valExpr"
        }
        if (domainChecks.isNotEmpty()) {
            sb.appendLine("  guard_domain$index : ${domainChecks.joinToString(" /\\ ")};")
        }

        // C. Reveal Consistency
        val revealChecks = meta.struct.visibility.filterValues { it == Visibility.REVEAL }.map { (field, _) ->
            val commitNodeId = dag.actions.firstOrNull { dag.visibilityOf(it)[field] == Visibility.COMMIT }!!
            val commitIndex = idToIndex[commitNodeId]!!
            val commitRole = dag.owner(commitNodeId)

            val hiddenName = paramName(field, true)
            val clearName = paramName(field, false)

            generateRevealExpression(commitIndex, commitRole, myRole, hiddenName.name, clearName.name, index)
        }
        if (revealChecks.isNotEmpty()) {
            sb.appendLine("  guard_reveal$index : ${revealChecks.joinToString(" /\\ ")};")
        }

        // D. Logic Guard
        val guardExpr = meta.spec.guardExpr
        if (guardExpr != Expr.Const.BoolVal(true)) {
            val exprCode = translateExpr(guardExpr, index)
            sb.appendLine("  guard_logic$index : ${stripParens(exprCode)};")
        }

        sb.appendLine("}.")
        sb.appendLine()
    }

    // --- Guard Generation Logic ---

    private fun generateRevealExpression(
        commitIndex: Int,
        commitRole: RoleId,
        myRole: RoleId,
        hiddenField: String,
        clearField: String,
        myIndex: Int // Passed down for monotonicity guard referencing
    ): String {
        return when (policy) {
            LivenessPolicy.FAIR_PLAY -> {
                "$clearField = reveal w$commitIndex.($hiddenField)"
            }
            LivenessPolicy.MONOTONIC -> {
                if (commitRole == myRole) {
                    // Safe access via getHave (monotonicity proven)
                    "$clearField = reveal (getHave w$commitIndex guard_monotonicity$myIndex).($hiddenField)"
                } else {
                    // External dependency: Strict Match
                    "(match w$commitIndex with Have w => $clearField = reveal w.($hiddenField) | Quit _ => False end)"
                }
            }
            LivenessPolicy.INDEPENDENT -> {
                // Always Strict Match
                "(match w$commitIndex with Present w => $clearField = reveal w.($hiddenField) | Absent _ => False end)"
            }
        }
    }

    private fun stripParens(exp: String): String =
        if (exp.startsWith("(") && exp.endsWith(")")) exp.drop(1).dropLast(1) else exp

    // --- Records: Run (Fair) & Execution (Trace) ---

    private fun appendFairPlayRun(sb: StringBuilder) {
        sb.appendLine("Record ActionDag : Type := {")
        sortedIds.forEachIndexed { i, _ ->
            val myAncestors = ancestors[i] ?: emptyList()

            // In MONOTONIC/INDEPENDENT, witnesses expect wrappers.
            // We must wrap the 'Run' fields in Have/Present to prove a fair run is possible.
            val wrapper = when(policy) {
                LivenessPolicy.FAIR_PLAY -> ""
                LivenessPolicy.MONOTONIC -> "(@Have _ _ "
                LivenessPolicy.INDEPENDENT -> "(@Present _ _ " // Though INDEPENDENT usually uses Execution
            }
            val suffix = if (policy == LivenessPolicy.FAIR_PLAY) "" else ")"

            val appArgs = myAncestors.joinToString(" ") { "${wrapper}action$it${suffix}" }
            val type = if (appArgs.isEmpty()) "@W$i" else "@W$i $appArgs"

            sb.appendLine("  action$i : $type;")
        }
        sb.appendLine("}.")
        sb.appendLine()
    }

    private fun appendExecutionRecord(sb: StringBuilder) {
        sb.appendLine("Record EventDag : Type := {")
        val wrapperName = if (policy == LivenessPolicy.INDEPENDENT) "Maybe" else "UnlessQuit"

        sortedIds.forEachIndexed { i, _ ->
            val myAncestors = ancestors[i] ?: emptyList()
            // In execution trace, we pass previous rows directly (they are already wrapped)
            val appArgs = myAncestors.joinToString(" ") { "event$it" }

            // The raw witness type (W$i) is defined expecting wrapped args.
            // So we just apply W$i rowA rowB.
            val witnessType = if (appArgs.isEmpty()) "W$i" else "W$i $appArgs"
            val role = dag.owner(sortedIds[i])

            sb.appendLine("  event$i : $wrapperName ${role.name} ($witnessType);")
        }
        sb.appendLine("}.")
        sb.appendLine()
    }

    // --- Expression Translation ---

    private fun translateExpr(e: Expr, currentIndex: Int): String {
        fun translate(e: Expr): String = when (e) {
            is Expr.Const.IntVal -> "${e.v}%Z"
            is Expr.Const.BoolVal -> if (e.v) "True" else "False"
            is Expr.Const.Hidden -> translate(e.inner)
            is Expr.Const.Opaque -> "0%Z"
            is Expr.Const.Quit -> "False"

            is Expr.Field -> {
                val writerIndex = fieldWriter[e.field]!!
                val fieldName = paramName(e.field, false).name

                if (writerIndex == currentIndex) {
                    fieldName
                } else if (policy == LivenessPolicy.FAIR_PLAY) {
                    "w$writerIndex.($fieldName)"
                } else {
                    // will be fixed at some point
                    fieldName
                }
            }

            is Expr.Add -> "(${translate(e.l)} + ${translate(e.r)})%Z"
            is Expr.Sub -> "(${translate(e.l)} - ${translate(e.r)})%Z"
            is Expr.Mul -> "(${translate(e.l)} * ${translate(e.r)})%Z"
            is Expr.Div -> "(${translate(e.l)} / ${translate(e.r)})%Z"
            is Expr.Neg -> "(- ${translate(e.x)})%Z"
            is Expr.Eq -> "(${translate(e.l)} = ${translate(e.r)})"
            is Expr.Ne -> "(${translate(e.l)} <> ${translate(e.r)})"
            is Expr.And -> "(${translate(e.l)} /\\ ${translate(e.r)})"
            is Expr.Or  -> "(${translate(e.l)} \\/ ${translate(e.r)})"
            is Expr.Not -> "(negb ${translate(e.x)})"
            is Expr.Gt -> "(${translate(e.l)} > ${translate(e.r)})"
            is Expr.Ge -> "(${translate(e.l)} >= ${translate(e.r)})"
            is Expr.Lt -> "(${translate(e.l)} < ${translate(e.r)})"
            is Expr.Le -> "(${translate(e.l)} <= ${translate(e.r)})"
            else -> "True"
        }
        return translate(e)
    }

    private fun toCoqType(t: Type): String = when (t) {
        is Type.IntType -> "Z"
        is Type.BoolType -> "bool"
        is Type.SetType -> "Z"
    }
}
