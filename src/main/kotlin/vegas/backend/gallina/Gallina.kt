package vegas.backend.gallina

import vegas.FieldRef
import vegas.RoleId
import vegas.VarId
import vegas.dag.Algo
import vegas.ir.*

class CoqDagEncoder(private val dag: ActionDag) {

    // 1. Topological Sort (Linearization of ids for naming 0..N)
    private val sortedIds: List<ActionId> by lazy {
        val adjacency = dag.actions.associateWith { dag.prerequisitesOf(it) }
        Algo.topo(dag.actions, adjacency)
    }

    private val idToIndex: Map<ActionId, Int> by lazy {
        sortedIds.withIndex().associate { it.value to it.index }
    }

    // 2. Transitive Ancestors Cache
    // Map<Index, List<Index>>: For each action i, which actions j < i are strict ancestors?
    // We store INDICES for easier code generation.
    private val ancestors: Map<Int, List<Int>> by lazy {
        val map = mutableMapOf<Int, List<Int>>()
        for (i in sortedIds.indices) {
            val id = sortedIds[i]
            val paramAncestors = dag.reach.ancestorsOf(id)
                .map { idToIndex[it]!! }
                .sorted() // Must be sorted to match the order of arguments in definitions
            map[i] = paramAncestors
        }
        map
    }

    // 3. Field Writers (Resolution for expressions)
    private val fieldWriter: Map<FieldRef, Int> by lazy {
        val map = mutableMapOf<FieldRef, Int>()
        for (id in dag.actions) {
            val struct = dag.meta(id).struct
            for ((field, vis) in struct.visibility) {
                // Only link to Visible writes (Public or Reveal)
                // Commits cannot be read by expressions
                if (vis == Visibility.PUBLIC || vis == Visibility.REVEAL) {
                    map[field] = idToIndex[id]!!
                }
            }
        }
        map
    }

    // --- Generation Entry Point ---

    fun generate(): String = buildString {
        appendPreamble()
        appendRoles()
        appendDomainDefinitions()

        appendLine("Module GameProtocol.")
        appendLine()

        // 1. Witnesses (The Logic/DAG structure)
        // Each W_i takes ancestors as arguments.
        sortedIds.forEachIndexed { index, id ->
            generateWitnessRecord(this, index, dag.meta(id))
        }

        // 2. The Run (Universal Quantifier)
        generateRunRecord(this)

        appendLine("End GameProtocol.")
    }

    // --- Helpers ---

    private fun StringBuilder.appendPreamble() {
        appendLine("(* Generated by Vegas Coq Encoder - Diamond DAG Strategy *)")
        appendLine("From Coq Require Import Bool.Bool.")
        appendLine("From Coq Require Import ZArith.ZArith.")
        appendLine("From Coq Require Import String.")
        appendLine()
        appendLine("Set Implicit Arguments.")
        appendLine("Set Primitive Projections.")
        appendLine()
        appendLine("Definition Hidden (A : Type) : Type := { x : A & unit }.")
        appendLine("Definition reveal {A} (h : Hidden A) : A := projT1 h.")
        appendLine()
    }

    private fun StringBuilder.appendRoles() {
        val roles = dag.actions.map { it.first }.distinct().sortedBy { it.name }
        append("Inductive Role : Type :=")
        if (roles.isEmpty()) append(" | Role_None")
        else roles.forEach { append(" | ${it.name}") }
        appendLine(".")
        appendLine()
    }

    private fun paramName(f: FieldRef, hidden: Boolean) =
        if (hidden) VarId("hidden_${f.param}_${f.owner}")
        else VarId("${f.param}_${f.owner}")

    // --- Witness Records (The Core DAG Logic) ---

    private fun generateWitnessRecord(sb: StringBuilder, index: Int, meta: ActionMeta) {
        val myAncestors = ancestors[index] ?: emptyList()
        val myRole = meta.struct.owner

        // Signature: Record W3 (w0: W0) (w1: W1 w0) ...
        sb.append("Record W$index")
        if (myAncestors.isNotEmpty()) {
            sb.appendLine()
            for (ancIndex in myAncestors) {
                // To define the TYPE of the argument w_k, we must apply W_k to ITS ancestors.
                // Since ancIndex < index, its ancestors are a subset of myAncestors.
                // They are therefore available as arguments we just declared previously.
                val ancAncestors = ancestors[ancIndex] ?: emptyList()
                val appArgs = ancAncestors.joinToString(" ") { "w$it" }

                if (appArgs.isEmpty()) {
                    sb.append("  (w$ancIndex : @W$ancIndex)")
                } else {
                    sb.append("  (w$ancIndex : @W$ancIndex $appArgs)")
                }
                sb.appendLine()
            }
        }
        sb.append(" : Type := {")
        sb.appendLine()

        // 1. Payload
        for (param in meta.spec.params) {
            val fieldRef = FieldRef(meta.struct.owner, param.name)
            val visibility = meta.struct.visibility[fieldRef] ?: Visibility.PUBLIC
            val coqType = toCoqType(param.type)

            if (visibility == Visibility.COMMIT) {
                sb.appendLine("  ${paramName(fieldRef, true)} : Hidden $coqType;")
            } else {
                sb.appendLine("  ${paramName(fieldRef, false)} : $coqType;")
            }
        }

        // B. Domain (guard_domain)
        val domainChecks = meta.spec.params.filter { it.type is Type.SetType }.map { param ->
            val typeId = setTypeMap[param.type]!!
            val domainName = "domain_Enum_$typeId"
            val fieldRef = FieldRef(myRole, param.name)
            val isCommit = meta.struct.visibility[fieldRef] == Visibility.COMMIT
            val varName = paramName(fieldRef, isCommit).name
            val valExpr = if (isCommit) "(reveal $varName)" else varName
            "$domainName $valExpr"
        }
        if (domainChecks.isNotEmpty()) {
            sb.appendLine("  guard_domain$index : ${domainChecks.joinToString(" /\\ ")};")
        }

        // C. Reveal Consistency (guard_reveal)
        val revealChecks = meta.struct.visibility.filterValues { it == Visibility.REVEAL }.map { (field, _) ->
            val commitNodeId = dag.actions.firstOrNull { dag.visibilityOf(it)[field] == Visibility.COMMIT }!!
            val commitIndex = idToIndex[commitNodeId]!!
            val commitRole = dag.owner(commitNodeId)

            val hiddenName = paramName(field, true)
            val clearName = paramName(field, false)

            val commitPath = if (commitRole != myRole) {
                "(match w$commitIndex with Have w => w.($hiddenName) | Quit _ => w.($hiddenName) end)"
            } else {
                "w$commitIndex.($hiddenName)"
            }
            "${clearName.name} = reveal $commitPath"
        }
        if (revealChecks.isNotEmpty()) {
            sb.appendLine("  guard_reveal$index : ${revealChecks.joinToString(" /\\ ")};")
        }

        // D. Logic (guard_logic)
        // We always generate this if it's not strictly true, to separate "Business Logic" from "System Logic"
        val guardExpr = meta.spec.guardExpr
        if (guardExpr != Expr.Const.BoolVal(true)) {
            val exprCode = translateExpr(guardExpr, index, myRole)
            sb.appendLine("  guard_logic$index : ${stripParens(exprCode)};")
        }
        sb.appendLine("}.")
        sb.appendLine()
    }

    private fun stripParens(exp: String): String = exp.drop(1).dropLast(1)

    // Map unique SetTypes to a stable ID (0, 1, 2...)
    private val setTypeMap: Map<Type.SetType, Int> by lazy {
        var counter = 0
        val map = mutableMapOf<Type.SetType, Int>()
        for (meta in dag.metas) {
            for (p in meta.spec.params) {
                if (p.type is Type.SetType && !map.containsKey(p.type)) {
                    map[p.type] = counter++
                }
            }
        }
        map
    }

    private fun StringBuilder.appendDomainDefinitions() {
        if (setTypeMap.isEmpty()) return

        appendLine("(* --- Domain Constraints --- *)")
        setTypeMap.toSortedMap(compareBy { it.values.toString() }).forEach { (type, id) ->
            val domainName = "domain_Enum_$id"
            append("Definition $domainName (z : Z) : Prop :=")
            if (type.values.isEmpty()) {
                append(" False.")
            } else {
                // z = 1 \/ z = 2 ...
                val disjunction = type.values.sorted().joinToString(" \\/ ") { v -> "z = $v%Z" }
                appendLine()
                appendLine("  $disjunction.")
            }
        }
        appendLine()
    }

    // --- The Universal Run Record ---

    private fun generateRunRecord(sb: StringBuilder) {
        sb.appendLine("Record Run : Type := {")
        for (i in sortedIds.indices) {
            val myAncestors = ancestors[i] ?: emptyList()
            val appArgs = myAncestors.joinToString(" ") { "row$it" }

            if (appArgs.isEmpty()) {
                sb.appendLine("  row$i : @W$i;")
            } else {
                sb.appendLine("  row$i : @W$i $appArgs;")
            }
        }
        sb.appendLine("}.")
    }

    // --- Expression Translation ---

    private fun translateExpr(e: Expr, currentIndex: Int, myRole: RoleId): String {
        fun translateExpr(e: Expr): String = when (e) {
            is Expr.Const.IntVal -> "${e.v}%Z"
            is Expr.Const.BoolVal -> if (e.v) "True" else "False"
            is Expr.Const.Hidden -> translateExpr(e.inner)
            is Expr.Const.Opaque -> "0%Z"
            is Expr.Const.Quit -> "False"

            is Expr.Field -> {
                val writerIndex = fieldWriter[e.field]!!
                val writerRole = dag.owner(sortedIds[writerIndex])
                val fieldName = paramName(e.field, false).name

                if (writerIndex == currentIndex) {
                    fieldName
                } else if (writerRole == myRole) {
                    "w$writerIndex.($fieldName)"
                } else {
                    // when quit is implemented, this would be different
                    "w$writerIndex.($fieldName)"
                }
            }

            is Expr.Add -> "(${translateExpr(e.l)} + ${translateExpr(e.r)})%Z"
            is Expr.Sub -> "(${translateExpr(e.l)} - ${translateExpr(e.r)})%Z"
            is Expr.Mul -> "(${translateExpr(e.l)} * ${translateExpr(e.r)})%Z"
            is Expr.Div -> "(${translateExpr(e.l)} / ${translateExpr(e.r)})%Z"
            is Expr.Neg -> "(- ${translateExpr(e.x)})%Z"

            is Expr.Eq -> "(${translateExpr(e.l)} = ${translateExpr(e.r)})"
            is Expr.Ne -> "(${translateExpr(e.l)} <> ${translateExpr(e.r)})"
            is Expr.And -> "(${translateExpr(e.l)} /\\ ${translateExpr(e.r)})"
            is Expr.Or  -> "(${translateExpr(e.l)} \\/ ${translateExpr(e.r)})"
            is Expr.Not -> "(negb ${translateExpr(e.x)})"

            is Expr.Gt -> "(${translateExpr(e.l)} > ${translateExpr(e.r)})"
            is Expr.Ge -> "(${translateExpr(e.l)} >= ${translateExpr(e.r)})"
            is Expr.Lt -> "(${translateExpr(e.l)} < ${translateExpr(e.r)})"
            is Expr.Le -> "(${translateExpr(e.l)} <= ${translateExpr(e.r)})"

            else -> "true (* Unsupported expr $e *)"
        }
        return translateExpr(e)
    }

    private fun toCoqType(t: Type): String = when (t) {
        is Type.IntType -> "Z"
        is Type.BoolType -> "bool"
        is Type.SetType -> "Z"
    }
}
