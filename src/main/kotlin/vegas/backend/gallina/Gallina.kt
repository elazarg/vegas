package vegas.backend.gallina

import vegas.FieldRef
import vegas.RoleId
import vegas.VarId
import vegas.dag.Algo
import vegas.ir.*

enum class LivenessPolicy {
    FAIR_PLAY,
    MONOTONIC,
    INDEPENDENT
}

class CoqDagEncoder(private val dag: ActionDag, private val policy: LivenessPolicy) {

    private val sortedIds: List<ActionId> by lazy {
        val adjacency = dag.actions.associateWith { dag.prerequisitesOf(it) }
        Algo.topo(dag.actions, adjacency)
    }

    private val idToIndex: Map<ActionId, Int> by lazy {
        sortedIds.withIndex().associate { it.value to it.index }
    }

    private val ancestors: Map<Int, List<Int>> by lazy {
        val map = mutableMapOf<Int, List<Int>>()
        for (i in sortedIds.indices) {
            val id = sortedIds[i]
            val paramAncestors = dag.reach.ancestorsOf(id)
                .map { idToIndex[it]!! }
                .sorted()
            map[i] = paramAncestors
        }
        map
    }

    private val fieldWriter: Map<FieldRef, Int> by lazy {
        val map = mutableMapOf<FieldRef, Int>()
        for (id in dag.actions) {
            val struct = dag.meta(id).struct
            for ((field, vis) in struct.visibility) {
                if (vis == Visibility.PUBLIC || vis == Visibility.REVEAL) {
                    map[field] = idToIndex[id]!!
                }
            }
        }
        map
    }

    private val setTypeMap: Map<Type.SetType, Int> by lazy {
        var counter = 0
        val map = mutableMapOf<Type.SetType, Int>()
        for (meta in dag.metas) {
            for (p in meta.spec.params) {
                if (p.type is Type.SetType && !map.containsKey(p.type)) {
                    map[p.type] = counter++
                }
            }
        }
        map
    }

    fun generate(): String = buildString {
        appendPreamble()
        appendRoles()
        appendQuitLogic()
        appendDomainDefinitions()

        appendLine("Module GameProtocol.")
        appendLine()

        sortedIds.forEachIndexed { index, id ->
            generateWitnessRecord(this, index, dag.meta(id))
        }

        when (policy) {
            LivenessPolicy.MONOTONIC -> {
                appendFairPlayRun(this)
                appendExecutionRecord(this)
            }
            LivenessPolicy.INDEPENDENT -> {
                appendExecutionRecord(this)
            }
            LivenessPolicy.FAIR_PLAY -> {
                appendFairPlayRun(this)
            }
        }

        appendLine("End GameProtocol.")
    }

    private fun StringBuilder.appendPreamble() {
        appendLine("(* Generated by Vegas Coq Encoder - Policy: $policy *)")
        appendLine("From Coq Require Import Bool.Bool.")
        appendLine("From Coq Require Import ZArith.ZArith.")
        appendLine("From Coq Require Import String.")
        appendLine()
        appendLine("Set Implicit Arguments.")
        appendLine("Set Primitive Projections.")
        appendLine()
        appendLine("Definition Hidden (A : Type) : Type := { x : A & unit }.")
        appendLine("Definition reveal {A} (h : Hidden A) : A := projT1 h.")
        appendLine()
    }

    private fun StringBuilder.appendRoles() {
        val roles = dag.actions.map { it.first }.distinct().sortedBy { it.name }
        append("Inductive Role : Type :=")
        if (roles.isEmpty()) append(" | Role_None")
        else roles.forEach { append(" | ${it.name}") }
        appendLine(".")
        appendLine()
    }

    private fun StringBuilder.appendQuitLogic() {
        if (policy == LivenessPolicy.FAIR_PLAY) return

        appendLine("(* --- Liveness Primitives --- *)")
        val failureName = if (policy == LivenessPolicy.INDEPENDENT) "Absence" else "QuitW"
        val wrapperName = if (policy == LivenessPolicy.INDEPENDENT) "Maybe" else "UnlessQuit"
        val presentName = if (policy == LivenessPolicy.INDEPENDENT) "Present" else "Have"
        val absentName  = if (policy == LivenessPolicy.INDEPENDENT) "Absent" else "Quit"

        appendLine("Inductive $failureName (r : Role) : Type := | Timeout : $failureName r.")
        appendLine()
        appendLine("Inductive $wrapperName (r : Role) (A : Type) : Type :=")
        appendLine("| $presentName : A -> $wrapperName r A")
        appendLine("| $absentName : $failureName r -> $wrapperName r A.")
        appendLine()
        appendLine("Arguments $presentName {r} {A} _.")
        appendLine("Arguments $absentName {r} {A} _.")
        appendLine()

        if (policy == LivenessPolicy.MONOTONIC) {
            appendLine("Definition IsHave {r A} (u : $wrapperName r A) : Prop :=")
            appendLine("  match u with $presentName _ => True | $absentName _ => False end.")
            appendLine()
            appendLine("Definition getHave {r A} (u : $wrapperName r A) : IsHave u -> A :=")
            appendLine("  match u with $presentName a => fun _ => a | $absentName _ => fun H => match H with end end.")
            appendLine()
        }

        appendLine("(* Helpers for accessing optional values and lifting operators *)")
        appendLine("Definition get_val {r A B} (u : $wrapperName r A) (f : A -> B) : option B :=")
        appendLine("  match u with $presentName w => Some (f w) | $absentName _ => None end.")
        appendLine()
        appendLine("Definition lift1 {A B} (f : A -> B) (x : option A) : option B :=")
        appendLine("  match x with Some v => Some (f v) | None => None end.")
        appendLine()
        appendLine("Definition lift2 {A B C} (f : A -> B -> C) (x : option A) (y : option B) : option C :=")
        appendLine("  match x, y with Some vx, Some vy => Some (f vx vy) | _, _ => None end.")
        appendLine()
    }

    private fun StringBuilder.appendDomainDefinitions() {
        if (setTypeMap.isEmpty()) return
        appendLine("(* --- Domain Constraints --- *)")
        setTypeMap.toSortedMap(compareBy { it.values.toString() }).forEach { (type, id) ->
            val domainName = "domain_Enum_$id"
            append("Definition $domainName (z : Z) : Prop :=")
            if (type.values.isEmpty()) append(" False.")
            else {
                val disjunction = type.values.sorted().joinToString(" \\/ ") { v -> "z = $v%Z" }
                appendLine()
                appendLine("  $disjunction.")
            }
        }
        appendLine()
    }

    private fun paramName(f: FieldRef, hidden: Boolean) =
        if (hidden) VarId("hidden_${f.param}_${f.owner}")
        else VarId("${f.param}_${f.owner}")

    private fun generateWitnessRecord(sb: StringBuilder, index: Int, meta: ActionMeta) {
        val myAncestors = ancestors[index] ?: emptyList()
        val myRole = meta.struct.owner

        sb.append("Record W$index")
        if (myAncestors.isNotEmpty()) {
            sb.appendLine()
            for (ancIndex in myAncestors) {
                val ancId = sortedIds[ancIndex]
                val ancRole = dag.owner(ancId)
                val ancAncestors = ancestors[ancIndex] ?: emptyList()
                val appArgs = ancAncestors.joinToString(" ") { "w$it" }
                val rawType = if (appArgs.isEmpty()) "@W$ancIndex" else "@W$ancIndex $appArgs"
                val finalType = when (policy) {
                    LivenessPolicy.FAIR_PLAY -> rawType
                    LivenessPolicy.MONOTONIC -> "UnlessQuit ${ancRole.name} ($rawType)"
                    LivenessPolicy.INDEPENDENT -> "Maybe ${ancRole.name} ($rawType)"
                }
                sb.append("  (w$ancIndex : $finalType)")
                sb.appendLine()
            }
        }
        sb.append(" : Type := {")
        sb.appendLine()

        // 2. Data Parameters
        for (param in meta.spec.params) {
            val fieldRef = FieldRef(myRole, param.name)
            val vis = meta.struct.visibility[fieldRef] ?: Visibility.PUBLIC
            val isCommit = (vis == Visibility.COMMIT)
            val typeStr = toCoqType(param.type)
            val name = paramName(fieldRef, isCommit)

            if (isCommit) sb.appendLine("  $name : Hidden $typeStr;")
            else sb.appendLine("  $name : $typeStr;")
        }
        if (meta.spec.params.isNotEmpty()) sb.appendLine()

        // --- 3. Guards ---

        // A. Monotonicity (Splitting fields to avoid tuple hell)
        if (policy == LivenessPolicy.MONOTONIC) {
            val selfDeps = myAncestors.filter { dag.owner(sortedIds[it]) == myRole }
            // Generate individual proofs for each ancestor
            selfDeps.forEach { depIndex ->
                sb.appendLine("  guard_have_w$depIndex : IsHave w$depIndex;")
            }
        }

        // B. Domain Constraints
        val domainChecks = meta.spec.params.filter { it.type is Type.SetType }.map { param ->
            val typeId = setTypeMap[param.type]!!
            val domainName = "domain_Enum_$typeId"
            val fieldRef = FieldRef(myRole, param.name)
            val isCommit = (meta.struct.visibility[fieldRef] == Visibility.COMMIT)
            val varName = paramName(fieldRef, isCommit).name
            val valExpr = if (isCommit) "(reveal $varName)" else varName
            "$domainName $valExpr"
        }
        if (domainChecks.isNotEmpty()) {
            sb.appendLine("  guard_domain$index : ${domainChecks.joinToString(" /\\ ")};")
        }

        // C. Reveal Consistency
        val revealChecks = meta.struct.visibility.filterValues { it == Visibility.REVEAL }.map { (field, _) ->
            val commitNodeId = dag.actions.firstOrNull { dag.visibilityOf(it)[field] == Visibility.COMMIT }!!
            val commitIndex = idToIndex[commitNodeId]!!
            val commitRole = dag.owner(commitNodeId)
            val hiddenName = paramName(field, true)
            val clearName = paramName(field, false)
            generateRevealExpression(commitIndex, commitRole, myRole, hiddenName.name, clearName.name)
        }
        if (revealChecks.isNotEmpty()) {
            sb.appendLine("  guard_reveal$index : ${revealChecks.joinToString(" /\\ ")};")
        }

        // D. Logic Guard
        val guardExpr = meta.spec.guardExpr
        if (guardExpr != Expr.Const.BoolVal(true)) {
            val exprCode = translateExpr(guardExpr, index)
            if (policy == LivenessPolicy.FAIR_PLAY) {
                sb.appendLine("  guard_logic$index : ${stripParens(exprCode)};")
            } else {
                sb.appendLine("  guard_logic$index : $exprCode = Some true;")
            }
        }
        sb.appendLine("}.")
        sb.appendLine()
    }

    private fun generateRevealExpression(
        commitIndex: Int,
        commitRole: RoleId,
        myRole: RoleId,
        hiddenField: String,
        clearField: String
    ): String {
        return when (policy) {
            LivenessPolicy.FAIR_PLAY -> {
                "$clearField = reveal w$commitIndex.($hiddenField)"
            }
            LivenessPolicy.MONOTONIC -> {
                if (commitRole == myRole) {
                    // Access using the named proof field we generated
                    "$clearField = reveal (getHave w$commitIndex guard_have_w$commitIndex).($hiddenField)"
                } else {
                    "(match w$commitIndex with Have w => $clearField = reveal w.($hiddenField) | Quit _ => False end)"
                }
            }
            LivenessPolicy.INDEPENDENT -> {
                "(match w$commitIndex with Present w => $clearField = reveal w.($hiddenField) | Absent _ => False end)"
            }
        }
    }

    private fun stripParens(exp: String): String =
        if (exp.startsWith("(") && exp.endsWith(")")) exp.drop(1).dropLast(1) else exp

    private fun appendFairPlayRun(sb: StringBuilder) {
        sb.appendLine("Record ActionDag : Type := {")
        sortedIds.forEachIndexed { i, _ ->
            val myAncestors = ancestors[i] ?: emptyList()
            val wrapper = when(policy) {
                LivenessPolicy.FAIR_PLAY -> ""
                LivenessPolicy.MONOTONIC -> "(@Have _ _ "
                LivenessPolicy.INDEPENDENT -> "(@Present _ _ "
            }
            val suffix = if (policy == LivenessPolicy.FAIR_PLAY) "" else ")"
            val appArgs = myAncestors.joinToString(" ") { "${wrapper}action$it${suffix}" }
            val type = if (appArgs.isEmpty()) "@W$i" else "@W$i $appArgs"
            sb.appendLine("  action$i : $type;")
        }
        sb.appendLine("}.")
        sb.appendLine()
    }

    private fun appendExecutionRecord(sb: StringBuilder) {
        sb.appendLine("Record EventDag : Type := {")
        val wrapperName = if (policy == LivenessPolicy.INDEPENDENT) "Maybe" else "UnlessQuit"
        sortedIds.forEachIndexed { i, _ ->
            val myAncestors = ancestors[i] ?: emptyList()
            val appArgs = myAncestors.joinToString(" ") { "event$it" }
            val witnessType = if (appArgs.isEmpty()) "@W$i" else "@W$i $appArgs"
            val role = dag.owner(sortedIds[i])
            sb.appendLine("  event$i : $wrapperName ${role.name} ($witnessType);")
        }
        sb.appendLine("}.")
        sb.appendLine()
    }

    private fun translateExpr(e: Expr, currentIndex: Int): String {
        fun translate(e: Expr): String = when (e) {
            // Parenthesize Option constructors to avoid "unknown context" parsing errors
            is Expr.Const.IntVal -> if (policy == LivenessPolicy.FAIR_PLAY) "${e.v}%Z" else "(Some ${e.v}%Z)"
            is Expr.Const.BoolVal -> if (policy == LivenessPolicy.FAIR_PLAY) (if(e.v) "True" else "False") else (if(e.v) "(Some true)" else "(Some false)")
            is Expr.Const.Hidden -> translate(e.inner)
            is Expr.Const.Opaque -> if (policy == LivenessPolicy.FAIR_PLAY) "0%Z" else "(Some 0%Z)"
            is Expr.Const.Quit -> if (policy == LivenessPolicy.FAIR_PLAY) "False" else "(Some false)"

            is Expr.Field -> {
                val writerIndex = fieldWriter[e.field]!!
                val fieldName = paramName(e.field, false).name

                if (writerIndex == currentIndex) {
                    if (policy == LivenessPolicy.FAIR_PLAY) fieldName else "(Some $fieldName)"
                } else {
                    if (policy == LivenessPolicy.FAIR_PLAY) {
                        "w$writerIndex.($fieldName)"
                    } else {
                        "(get_val w$writerIndex (fun w => w.($fieldName)))"
                    }
                }
            }

            is Expr.Add -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} + ${translate(e.r)})%Z"
            else "(lift2 Z.add ${translate(e.l)} ${translate(e.r)})"

            is Expr.Sub -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} - ${translate(e.r)})%Z"
            else "(lift2 Z.sub ${translate(e.l)} ${translate(e.r)})"

            is Expr.Mul -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} * ${translate(e.r)})%Z"
            else "(lift2 Z.mul ${translate(e.l)} ${translate(e.r)})"

            is Expr.Div -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} / ${translate(e.r)})%Z"
            else "(lift2 Z.div ${translate(e.l)} ${translate(e.r)})"

            is Expr.Neg -> if (policy == LivenessPolicy.FAIR_PLAY) "(- ${translate(e.x)})%Z"
            else "(lift1 Z.opp ${translate(e.x)})"

            is Expr.Eq -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} = ${translate(e.r)})"
            else "(lift2 (fun x y => Z.eqb x y) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Ne -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} <> ${translate(e.r)})"
            else "(lift2 (fun x y => negb (Z.eqb x y)) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Gt -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} > ${translate(e.r)})"
            else "(lift2 Z.gtb ${translate(e.l)} ${translate(e.r)})"

            is Expr.Ge -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} >= ${translate(e.r)})"
            else "(lift2 Z.geb ${translate(e.l)} ${translate(e.r)})"

            is Expr.Lt -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} < ${translate(e.r)})"
            else "(lift2 Z.ltb ${translate(e.l)} ${translate(e.r)})"

            is Expr.Le -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} <= ${translate(e.r)})"
            else "(lift2 Z.leb ${translate(e.l)} ${translate(e.r)})"

            is Expr.And -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} /\\ ${translate(e.r)})"
            else "(lift2 (fun a b => andb a b) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Or -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} \\/ ${translate(e.r)})"
            else "(lift2 (fun a b => orb a b) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Not -> if (policy == LivenessPolicy.FAIR_PLAY) "(negb ${translate(e.x)})"
            else "(lift1 negb ${translate(e.x)})"

            else -> if (policy == LivenessPolicy.FAIR_PLAY) "True" else "(Some true)"
        }
        return translate(e)
    }

    private fun toCoqType(t: Type): String = when (t) {
        is Type.IntType -> "Z"
        is Type.BoolType -> "bool"
        is Type.SetType -> "Z"
    }
}