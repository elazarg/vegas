package vegas.backend.gallina

import vegas.FieldRef
import vegas.VarId
import vegas.dag.Algo
import vegas.ir.*

class CoqDagEncoder(private val dag: ActionDag) {

    // 1. Topological Sort (Linearization of ids for naming 0..N)
    private val sortedIds: List<ActionId> by lazy {
        val adjacency = dag.actions.associateWith { dag.prerequisitesOf(it) }
        Algo.topo(dag.actions, adjacency)
    }

    private val idToIndex: Map<ActionId, Int> by lazy {
        sortedIds.withIndex().associate { it.value to it.index }
    }

    // 2. Transitive Ancestors Cache
    // Map<Index, List<Index>>: For each action i, which actions j < i are strict ancestors?
    // We store INDICES for easier code generation.
    private val ancestors: Map<Int, List<Int>> by lazy {
        val map = mutableMapOf<Int, List<Int>>()
        for (i in sortedIds.indices) {
            val id = sortedIds[i]
            val paramAncestors = dag.reach.ancestorsOf(id)
                .map { idToIndex[it]!! }
                .sorted() // Must be sorted to match the order of arguments in definitions
            map[i] = paramAncestors
        }
        map
    }

    // 3. Field Writers (Resolution for expressions)
    private val fieldWriter: Map<FieldRef, Int> by lazy {
        val map = mutableMapOf<FieldRef, Int>()
        for (id in dag.actions) {
            val struct = dag.meta(id).struct
            for ((field, vis) in struct.visibility) {
                // Only link to Visible writes (Public or Reveal)
                // Commits cannot be read by expressions
                if (vis == Visibility.PUBLIC || vis == Visibility.REVEAL) {
                    map[field] = idToIndex[id]!!
                }
            }
        }
        map
    }

    // --- Generation Entry Point ---

    fun generate(): String = buildString {
        appendPreamble()
        appendRoles()
        appendEnums()

        appendLine("Module GameProtocol.")
        appendLine()

        // 1. Payloads (Data carried by each step)
        sortedIds.forEachIndexed { index, id ->
            generatePayloadRecord(this, index, dag.meta(id))
        }

        // 2. Witnesses (The Logic/DAG structure)
        // Each W_i takes ancestors as arguments.
        sortedIds.forEachIndexed { index, id ->
            generateWitnessRecord(this, index, dag.meta(id))
        }

        // 3. The Run (Universal Quantifier)
        generateRunRecord(this)

        appendLine("End GameProtocol.")
    }

    // --- Helpers ---

    private fun StringBuilder.appendPreamble() {
        appendLine("(* Generated by Vegas Coq Encoder - Diamond DAG Strategy *)")
        appendLine("From Coq Require Import Bool.Bool.")
        appendLine("From Coq Require Import ZArith.ZArith.")
        appendLine("From Coq Require Import String.")
        appendLine()
        appendLine("Set Implicit Arguments.")
        appendLine()
        appendLine("Definition Hidden (A : Type) : Type := { x : A & unit }.")
        appendLine("Definition reveal {A} (h : Hidden A) : A := projT1 h.")
        appendLine()
    }

    private fun StringBuilder.appendRoles() {
        val roles = dag.actions.map { it.first }.distinct().sortedBy { it.name }
        append("Inductive Role : Type :=")
        if (roles.isEmpty()) append(" | Role_None")
        else roles.forEach { append(" | ${it.name}") }
        appendLine(".")
        appendLine()
    }

    private fun StringBuilder.appendEnums() {
        val setTypes = mutableSetOf<Type.SetType>()
        for (meta in dag.metas) {
            for (param in meta.spec.params) {
                if (param.type is Type.SetType) setTypes.add(param.type)
            }
        }

        setTypes.forEachIndexed { i, type ->
            appendLine("Inductive Enum_$i : Type :=")
            type.values.sorted().forEach { v -> appendLine("| E${i}_v$v") }
            appendLine(".")
            appendLine("Scheme Equality for Enum_$i.")
            appendLine()
        }
    }

    private fun paramName(f: FieldRef, hidden: Boolean) =
        if (hidden) VarId("hidden_${f.param}_${f.owner}")
        else VarId("${f.param}_${f.owner}")

    // --- Payload ---

    private fun generatePayloadRecord(sb: StringBuilder, index: Int, meta: ActionMeta) {
        val params = meta.spec.params
        if (params.isEmpty()) {
            sb.appendLine("Definition P_Action$index : Type := unit.")
            return
        }

        sb.appendLine("Record P_Action$index : Type := {")
        for (param in params) {
            val fieldRef = FieldRef(meta.struct.owner, param.name)
            val visibility = meta.struct.visibility[fieldRef] ?: Visibility.PUBLIC
            val coqType = toCoqType(param.type)

            if (visibility == Visibility.COMMIT) {
                sb.appendLine("  ${paramName(fieldRef, true)} : Hidden ($coqType);")
            } else {
                sb.appendLine("  ${paramName(fieldRef, false)} : $coqType;")
            }
        }
        sb.appendLine("}.")
        sb.appendLine()
    }

    // --- Witness Records (The Core DAG Logic) ---

    private fun generateWitnessRecord(sb: StringBuilder, index: Int, meta: ActionMeta) {
        val myAncestors = ancestors[index] ?: emptyList()

        // Signature: Record W3 (w0: W0) (w1: W1 w0) ...
        sb.append("Record W$index")
        if (myAncestors.isNotEmpty()) {
            sb.appendLine()
            for (ancIndex in myAncestors) {
                // To define the TYPE of the argument w_k, we must apply W_k to ITS ancestors.
                // Since ancIndex < index, its ancestors are a subset of myAncestors.
                // They are therefore available as arguments we just declared previously.
                val ancAncestors = ancestors[ancIndex] ?: emptyList()
                val appArgs = ancAncestors.joinToString(" ") { "w$it" }

                if (appArgs.isEmpty()) {
                    sb.append("  (w$ancIndex : @W$ancIndex)")
                } else {
                    sb.append("  (w$ancIndex : @W$ancIndex $appArgs)")
                }
                sb.appendLine()
            }
        }
        sb.append(" : Type := {")
        sb.appendLine()

        // 1. Payload
        sb.appendLine("  payload$index : P_Action$index;")

        // 2. Guard
        sb.appendGuard(index, meta)

        sb.appendLine()
        sb.appendLine("}.")
        sb.appendLine()
    }

    private fun StringBuilder.appendGuard(currentIndex: Int, meta: ActionMeta) {
        val conditions = mutableListOf<String>()

        // A. Explicit Logic Guard
        val guardExpr = meta.spec.guardExpr
        if (guardExpr != Expr.Const.BoolVal(true)) {
            conditions.add(translateExpr(guardExpr, currentIndex))
        }

        // B. Reveal Consistency Checks
        // payload.x = reveal( w_commit.payload.hidden_x )
        for ((field, vis) in meta.struct.visibility) {
            if (vis == Visibility.REVEAL) {
                // Find the COMMIT node
                val commitNodeId = dag.actions.firstOrNull {
                    dag.visibilityOf(it)[field] == Visibility.COMMIT
                }

                if (commitNodeId != null) {
                    val commitIndex = idToIndex[commitNodeId]!!
                    // The commit node MUST be an ancestor for this to be valid IR.
                    // We access it via the argument 'w_commitIndex'

                    val commitPath = "w$commitIndex.(payload$commitIndex).(${paramName(field, true)})"
                    val revealPath = "payload$currentIndex.(${paramName(field, false)})"

                    conditions.add("$revealPath = reveal $commitPath")
                }
            }
        }

        append("  guard$currentIndex : ")
        if (conditions.isEmpty()) append("True")
        else append(conditions.joinToString(" /\\ "))
        append(";")
    }

    // --- The Universal Run Record ---

    private fun generateRunRecord(sb: StringBuilder) {
        sb.appendLine("Record Run : Type := {")
        for (i in sortedIds.indices) {
            val myAncestors = ancestors[i] ?: emptyList()
            val appArgs = myAncestors.joinToString(" ") { "row$it" }

            if (appArgs.isEmpty()) {
                sb.appendLine("  row$i : @W$i;")
            } else {
                sb.appendLine("  row$i : @W$i $appArgs;")
            }
        }
        sb.appendLine("}.")
    }

    // --- Expression Translation ---

    private fun translateExpr(e: Expr, currentIndex: Int): String = when (e) {
        is Expr.Const.IntVal -> "${e.v}%Z"
        is Expr.Const.BoolVal -> if (e.v) "True" else "False"
        is Expr.Const.Hidden -> translateExpr(e.inner, currentIndex)
        is Expr.Const.Opaque -> "0%Z"
        is Expr.Const.Quit -> "False"

        is Expr.Field -> {
            // Find who wrote this field
            val writerIndex = fieldWriter[e.field]
                ?: error("No visible writer for ${e.field} (check if it's hidden)")

            val varName = paramName(e.field, false).name

            if (writerIndex == currentIndex) {
                // Reading my own parameter (e.g. in a join or guard check)
                "payload$currentIndex.($varName)"
            } else {
                // Reading an ancestor
                // Since this is a valid read, writerIndex MUST be in ancestors[currentIndex]
                "w$writerIndex.(payload$writerIndex).($varName)"
            }
        }

        is Expr.Add -> "(${translateExpr(e.l, currentIndex)} + ${translateExpr(e.r, currentIndex)})%Z"
        is Expr.Sub -> "(${translateExpr(e.l, currentIndex)} - ${translateExpr(e.r, currentIndex)})%Z"
        is Expr.Mul -> "(${translateExpr(e.l, currentIndex)} * ${translateExpr(e.r, currentIndex)})%Z"
        is Expr.Div -> "(${translateExpr(e.l, currentIndex)} / ${translateExpr(e.r, currentIndex)})%Z"
        is Expr.Neg -> "(- ${translateExpr(e.x, currentIndex)})%Z"

        is Expr.Eq -> "(${translateExpr(e.l, currentIndex)} = ${translateExpr(e.r, currentIndex)})"
        is Expr.Ne -> "(${translateExpr(e.l, currentIndex)} <> ${translateExpr(e.r, currentIndex)})"
        is Expr.And -> "(${translateExpr(e.l, currentIndex)} /\\ ${translateExpr(e.r, currentIndex)})"
        is Expr.Or  -> "(${translateExpr(e.l, currentIndex)} \\/ ${translateExpr(e.r, currentIndex)})"
        is Expr.Not -> "(negb ${translateExpr(e.x, currentIndex)})"

        is Expr.Gt -> "(${translateExpr(e.l, currentIndex)} > ${translateExpr(e.r, currentIndex)})"
        is Expr.Ge -> "(${translateExpr(e.l, currentIndex)} >= ${translateExpr(e.r, currentIndex)})"
        is Expr.Lt -> "(${translateExpr(e.l, currentIndex)} < ${translateExpr(e.r, currentIndex)})"
        is Expr.Le -> "(${translateExpr(e.l, currentIndex)} <= ${translateExpr(e.r, currentIndex)})"

        else -> "true (* Unsupported expr $e *)"
    }

    private fun toCoqType(t: Type): String = when (t) {
        is Type.IntType -> "Z"
        is Type.BoolType -> "bool"
        is Type.SetType -> "nat" // In real impl, map to Enum_X
    }
}
