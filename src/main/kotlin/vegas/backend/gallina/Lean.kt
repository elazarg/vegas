package vegas.backend.gallina

import vegas.FieldRef
import vegas.VarId
import vegas.dag.Algo
import vegas.ir.*

/**
 * Generates a Lean 4 deep embedding of a Vegas Game Protocol.
 *
 * This is a port of the Coq/Gallina encoder to Lean 4, following the same
 * theoretical approach (Diamond DAG Strategy) but using idiomatic Lean 4 syntax.
 *
 * # Key Differences from Coq
 *
 * - Uses `structure` instead of `Record`
 * - Uses `Int` for integers (Lean's arbitrary-precision integers)
 * - Uses `Option` instead of `option`
 * - Uses `decide` for decidable propositions in guards
 * - Projections use dot notation: `w.field` instead of `w.(field)`
 * - Dependent types use explicit `(x : T)` syntax in structure parameters
 *
 * See [CoqDagEncoder] for the full theoretical background.
 */
class LeanDagEncoder(private val dag: ActionDag, private val policy: LivenessPolicy) {

    private val sortedIds: List<ActionId> by lazy {
        val adjacency = dag.actions.associateWith { dag.prerequisitesOf(it) }
        Algo.topo(dag.actions, adjacency)
    }

    private val idToIndex: Map<ActionId, Int> by lazy {
        sortedIds.withIndex().associate { it.value to it.index }
    }

    private val ancestors: Map<Int, List<Int>> by lazy {
        val map = mutableMapOf<Int, List<Int>>()
        for (i in sortedIds.indices) {
            val id = sortedIds[i]
            val paramAncestors = dag.reach.ancestorsOf(id)
                .map { idToIndex[it]!! }
                .sorted()
            map[i] = paramAncestors
        }
        map
    }

    private val rangeTypeMap: Map<Type.RangeType, Int> by lazy {
        var counter = 0
        val map = mutableMapOf<Type.RangeType, Int>()
        for (meta in dag.metas) {
            for (p in meta.spec.params) {
                if (p.type is Type.RangeType && !map.containsKey(p.type)) {
                    map[p.type] = counter++
                }
            }
        }
        map
    }

    fun generate(): String = buildString {
        appendPreamble()
        appendRoles()
        appendQuitLogic()
        appendDomainDefinitions()

        appendLine("namespace GameProtocol")
        appendLine()

        sortedIds.forEachIndexed { index, id ->
            generateWitnessStructure(this, index, dag.meta(id))
        }

        when (policy) {
            LivenessPolicy.MONOTONIC -> {
                appendFairPlayRun(this)
                appendExecutionRecord(this)
            }
            LivenessPolicy.INDEPENDENT -> {
                appendExecutionRecord(this)
            }
            LivenessPolicy.FAIR_PLAY -> {
                appendFairPlayRun(this)
            }
        }

        appendLine("end GameProtocol")
    }

    private fun StringBuilder.appendPreamble() {
        appendLine("/- Generated by Vegas Lean Encoder - Policy: $policy -/")
        appendLine()
        appendLine("set_option autoImplicit false")
        appendLine()
        appendLine("/-- Hidden value with commitment semantics -/")
        appendLine("structure Hidden (A : Type) where")
        appendLine("  val : A")
        appendLine()
        appendLine("def Hidden.reveal {A : Type} (h : Hidden A) : A := h.val")
        appendLine()
    }

    private fun StringBuilder.appendRoles() {
        val roles = dag.actions.map { it.first }.distinct().sortedBy { it.name }
        appendLine("/-- Game roles -/")
        if (roles.isEmpty()) {
            appendLine("inductive Role : Type where")
            appendLine("  | None : Role")
        } else {
            appendLine("inductive Role : Type where")
            roles.forEach { appendLine("  | ${it.name} : Role") }
        }
        appendLine()
    }

    private fun StringBuilder.appendQuitLogic() {
        if (policy == LivenessPolicy.FAIR_PLAY) return

        appendLine("/- Liveness Primitives -/")
        val failureName = if (policy == LivenessPolicy.INDEPENDENT) "Absence" else "QuitW"
        val wrapperName = if (policy == LivenessPolicy.INDEPENDENT) "Maybe" else "UnlessQuit"
        val presentName = if (policy == LivenessPolicy.INDEPENDENT) "present" else "have"
        val absentName = if (policy == LivenessPolicy.INDEPENDENT) "absent" else "quit"

        appendLine("inductive $failureName (r : Role) : Type where")
        appendLine("  | timeout : $failureName r")
        appendLine()
        appendLine("inductive $wrapperName (r : Role) (A : Type) : Type where")
        appendLine("  | $presentName : A → $wrapperName r A")
        appendLine("  | $absentName : $failureName r → $wrapperName r A")
        appendLine()

        val capPresent = presentName.replaceFirstChar { it.uppercase() }

        appendLine("def ${wrapperName}.is$capPresent {r : Role} {A : Type} : $wrapperName r A → Prop")
        appendLine("  | .$presentName _ => True")
        appendLine("  | .$absentName _ => False")
        appendLine()

        appendLine("def ${wrapperName}.get$capPresent {r : Role} {A : Type} (u : $wrapperName r A) (h : u.is$capPresent) : A :=")
        appendLine("  match u with")
        appendLine("  | .$presentName a => a")
        appendLine("  | .$absentName _ => False.elim h")
        appendLine()

        appendLine("/-- Extract value from wrapper, returning Option -/")
        appendLine("def ${wrapperName}.getVal {r : Role} {A B : Type} (u : $wrapperName r A) (f : A → B) : Option B :=")
        appendLine("  match u with")
        appendLine("  | .$presentName w => some (f w)")
        appendLine("  | .$absentName _ => none")
        appendLine()

        appendLine("/-- Lift unary function over Option -/")
        appendLine("def lift1 {A B : Type} (f : A → B) : Option A → Option B")
        appendLine("  | some v => some (f v)")
        appendLine("  | none => none")
        appendLine()

        appendLine("/-- Lift binary function over Option -/")
        appendLine("def lift2 {A B C : Type} (f : A → B → C) : Option A → Option B → Option C")
        appendLine("  | some vx, some vy => some (f vx vy)")
        appendLine("  | _, _ => none")
        appendLine()
    }

    private fun StringBuilder.appendDomainDefinitions() {
        if (rangeTypeMap.isEmpty()) return
        appendLine("/- Domain Constraints -/")
        rangeTypeMap.toSortedMap(compareBy { "${it.min}_${it.max}" }).forEach { (type, id) ->
            val domainName = "domain_Enum_$id"
            appendLine("def $domainName (z : Int) : Prop := ${type.min} ≤ z ∧ z ≤ ${type.max}")
        }
        appendLine()
    }

    private fun paramName(f: FieldRef, hidden: Boolean) =
        if (hidden) VarId("hidden_${f.param}_${f.owner}")
        else VarId("${f.param}_${f.owner}")

    private fun commitSourceIndex(currentIndex: Int, field: FieldRef): Int {
        val cand = ancestors.getValue(currentIndex)
            .filter { ai ->
                val id = sortedIds[ai]
                dag.visibilityOf(id)[field] == Visibility.COMMIT
            }
        return cand.maxOrNull()
            ?: error("No commit ancestor for reveal field $field at action $currentIndex")
    }

    private fun generateWitnessStructure(sb: StringBuilder, index: Int, meta: ActionMeta) {
        val myAncestors = ancestors[index] ?: emptyList()
        val myRole = meta.struct.owner

        // Structure header with parameters
        sb.append("structure ${actionName(index)}")
        if (myAncestors.isNotEmpty()) {
            sb.appendLine()
            for (ancIndex in myAncestors) {
                val ancId = sortedIds[ancIndex]
                val ancRole = dag.owner(ancId)
                val ancAncestors = ancestors[ancIndex] ?: emptyList()
                val appArgs = ancAncestors.joinToString(" ") { "w$it" }
                val rawType = if (appArgs.isEmpty()) actionName(ancIndex) else "${actionName(ancIndex)} $appArgs"
                val finalType = when (policy) {
                    LivenessPolicy.FAIR_PLAY -> rawType
                    LivenessPolicy.MONOTONIC -> "UnlessQuit Role.${ancRole.name} ($rawType)"
                    LivenessPolicy.INDEPENDENT -> "Maybe Role.${ancRole.name} ($rawType)"
                }
                sb.appendLine("    (w$ancIndex : $finalType)")
            }
            sb.append("    ")
        } else {
            sb.append(" ")
        }
        sb.appendLine(": Type where")

        // Data Parameters
        for (param in meta.spec.params) {
            val fieldRef = FieldRef(myRole, param.name)
            val vis = meta.struct.visibility[fieldRef] ?: Visibility.PUBLIC
            val isCommit = (vis == Visibility.COMMIT)
            val typeStr = toLeanType(param.type)
            val name = paramName(fieldRef, isCommit)

            if (isCommit) sb.appendLine("  $name : Hidden $typeStr")
            else sb.appendLine("  $name : $typeStr")
        }

        // Guards

        // A. Monotonicity guards
        if (policy == LivenessPolicy.MONOTONIC) {
            val selfDeps = myAncestors.filter { dag.owner(sortedIds[it]) == myRole }
            selfDeps.forEach { depIndex ->
                sb.appendLine("  ${actionName(index)}_${monotonicityGuardName(depIndex)} : w$depIndex.isHave")
            }
        }

        // B. Domain Constraints
        val domainChecks = meta.spec.params.filter { it.type is Type.RangeType }
        for (param in domainChecks) {
            val typeId = rangeTypeMap[param.type]!!
            val domainName = "domain_Enum_$typeId"
            val fieldRef = FieldRef(myRole, param.name)
            val isCommit = (meta.struct.visibility[fieldRef] == Visibility.COMMIT)
            val varName = paramName(fieldRef, isCommit).name
            val valExpr = if (isCommit) "$varName.reveal" else varName
            sb.appendLine("  ${actionName(index)}_guard_domain_$varName : $domainName $valExpr")
        }

        // C. Reveal Consistency
        for ((field, visibility) in meta.struct.visibility) {
            if (visibility != Visibility.REVEAL) continue
            val commitIndex = commitSourceIndex(index, field)
            val commitRole = dag.owner(sortedIds[commitIndex])
            val hiddenName = paramName(field, true)
            val clearName = paramName(field, false)
            val guardName = "${actionName(index)}_guard_reveal_$clearName"

            when (policy) {
                LivenessPolicy.FAIR_PLAY -> {
                    sb.appendLine("  $guardName : $clearName = w$commitIndex.$hiddenName.reveal")
                }
                LivenessPolicy.MONOTONIC -> {
                    require(commitRole == myRole)
                    sb.appendLine("  $guardName : $clearName = (w$commitIndex.getHave ${actionName(index)}_${monotonicityGuardName(commitIndex)}).$hiddenName.reveal")
                }
                LivenessPolicy.INDEPENDENT -> {
                    val guardPresentName = "${actionName(index)}_guard_w${commitIndex}_present"
                    sb.appendLine("  $guardPresentName : w${commitIndex}.isPresent")
                    sb.appendLine("  $guardName : $clearName = (w$commitIndex.getPresent $guardPresentName).$hiddenName.reveal")
                }
            }
        }

        // D. Logic Guard
        val guardExpr = meta.spec.guardExpr
        if (guardExpr != Expr.Const.BoolVal(true)) {
            val exprCode = translateExpr(guardExpr, index)
            val propify = if (policy == LivenessPolicy.FAIR_PLAY) "true" else "some true"
            sb.appendLine("  ${actionName(index)}_guard_logic : $exprCode = $propify")
        }

        sb.appendLine()
    }

    private fun monotonicityGuardName(depIndex: Int): String = "guard_have_w$depIndex"

    private fun appendFairPlayRun(sb: StringBuilder) {
        sb.appendLine("structure ActionDag : Type where")
        sortedIds.forEachIndexed { i, _ ->
            val myAncestors = ancestors[i] ?: emptyList()
            val wrapper = when (policy) {
                LivenessPolicy.FAIR_PLAY -> ""
                LivenessPolicy.MONOTONIC -> "(UnlessQuit.have "
                LivenessPolicy.INDEPENDENT -> "(Maybe.present "
            }
            val suffix = if (policy == LivenessPolicy.FAIR_PLAY) "" else ")"
            val appArgs = myAncestors.joinToString(" ") { "${wrapper}action$it${suffix}" }
            val type = if (appArgs.isEmpty()) actionName(i) else "${actionName(i)} $appArgs"
            sb.appendLine("  action$i : $type")
        }
        sb.appendLine()
    }

    private fun appendExecutionRecord(sb: StringBuilder) {
        val wrapperName = if (policy == LivenessPolicy.INDEPENDENT) "Maybe" else "UnlessQuit"
        sb.appendLine("structure EventDag : Type where")
        sortedIds.forEachIndexed { i, _ ->
            val myAncestors = ancestors[i] ?: emptyList()
            val appArgs = myAncestors.joinToString(" ") { "event$it" }
            val witnessType = if (appArgs.isEmpty()) actionName(i) else "${actionName(i)} $appArgs"
            val role = dag.owner(sortedIds[i])
            sb.appendLine("  event$i : $wrapperName Role.${role.name} ($witnessType)")
        }
        sb.appendLine()
    }

    private fun actionName(index: Int): String = "W$index"

    private fun latestWriterIndex(currentIndex: Int, field: FieldRef): Int? {
        val candidates = ancestors.getValue(currentIndex) + currentIndex
        return candidates
            .filter { idx -> dag.visibilityOf(sortedIds[idx]).containsKey(field) }
            .maxOrNull()
    }

    private fun leanFieldName(field: FieldRef, hidden: Boolean): String =
        paramName(field, hidden).name

    private fun fieldReadExpr(field: FieldRef, currentIndex: Int): String {
        val reader = dag.owner(sortedIds[currentIndex])
        val writerIndex = latestWriterIndex(currentIndex, field)
            ?: error("No writer for field $field at action $currentIndex")

        val writerId = sortedIds[writerIndex]
        val vis = dag.visibilityOf(writerId)[field]!!

        val isLocal = writerIndex == currentIndex

        fun wrapSome(x: String) = if (policy == LivenessPolicy.FAIR_PLAY) x else "(some $x)"
        fun none() = if (policy == LivenessPolicy.FAIR_PLAY)
            error("In FAIR_PLAY, guard referenced unavailable/hidden field $field for non-owner")
        else "none"

        return when (vis) {
            Visibility.PUBLIC, Visibility.REVEAL -> {
                val clear = leanFieldName(field, hidden = false)
                if (isLocal) wrapSome(clear)
                else if (policy == LivenessPolicy.FAIR_PLAY) "w$writerIndex.$clear"
                else "(w$writerIndex.getVal (fun w => w.$clear))"
            }

            Visibility.COMMIT -> {
                if (field.owner != reader) return none()

                val hid = leanFieldName(field, hidden = true)

                if (isLocal) {
                    wrapSome("$hid.reveal")
                } else {
                    if (policy == LivenessPolicy.FAIR_PLAY) {
                        "w$writerIndex.$hid.reveal"
                    } else {
                        "(lift1 Hidden.reveal (w$writerIndex.getVal (fun w => w.$hid)))"
                    }
                }
            }
        }
    }

    private fun translateExpr(e: Expr, currentIndex: Int): String {
        fun translate(e: Expr): String = when (e) {
            is Expr.Const.IntVal -> if (policy == LivenessPolicy.FAIR_PLAY) "(${e.v} : Int)" else "(some (${e.v} : Int))"
            is Expr.Const.BoolVal -> if (policy == LivenessPolicy.FAIR_PLAY) (if (e.v) "true" else "false") else (if (e.v) "(some true)" else "(some false)")
            is Expr.Const.Hidden -> translate(e.inner)
            is Expr.Const.Opaque -> if (policy == LivenessPolicy.FAIR_PLAY) "(0 : Int)" else "(some (0 : Int))"
            is Expr.Const.Quit -> if (policy == LivenessPolicy.FAIR_PLAY) "false" else "(some false)"

            is Expr.Field -> fieldReadExpr(e.field, currentIndex)

            is Expr.Add -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} + ${translate(e.r)})"
            else "(lift2 (· + ·) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Sub -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} - ${translate(e.r)})"
            else "(lift2 (· - ·) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Mul -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} * ${translate(e.r)})"
            else "(lift2 (· * ·) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Div -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} / ${translate(e.r)})"
            else "(lift2 (· / ·) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Neg -> if (policy == LivenessPolicy.FAIR_PLAY) "(-${translate(e.x)})"
            else "(lift1 (- ·) ${translate(e.x)})"

            // Comparisons
            is Expr.Eq -> if (policy == LivenessPolicy.FAIR_PLAY) "(decide (${translate(e.l)} = ${translate(e.r)}))"
            else "(lift2 (fun x y => decide (x = y)) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Ne -> if (policy == LivenessPolicy.FAIR_PLAY) "(decide (${translate(e.l)} ≠ ${translate(e.r)}))"
            else "(lift2 (fun x y => decide (x ≠ y)) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Gt -> if (policy == LivenessPolicy.FAIR_PLAY) "(decide (${translate(e.l)} > ${translate(e.r)}))"
            else "(lift2 (fun x y => decide (x > y)) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Ge -> if (policy == LivenessPolicy.FAIR_PLAY) "(decide (${translate(e.l)} ≥ ${translate(e.r)}))"
            else "(lift2 (fun x y => decide (x ≥ y)) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Lt -> if (policy == LivenessPolicy.FAIR_PLAY) "(decide (${translate(e.l)} < ${translate(e.r)}))"
            else "(lift2 (fun x y => decide (x < y)) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Le -> if (policy == LivenessPolicy.FAIR_PLAY) "(decide (${translate(e.l)} ≤ ${translate(e.r)}))"
            else "(lift2 (fun x y => decide (x ≤ y)) ${translate(e.l)} ${translate(e.r)})"

            // Boolean Logic
            is Expr.And -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} && ${translate(e.r)})"
            else "(lift2 (· && ·) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Or -> if (policy == LivenessPolicy.FAIR_PLAY) "(${translate(e.l)} || ${translate(e.r)})"
            else "(lift2 (· || ·) ${translate(e.l)} ${translate(e.r)})"

            is Expr.Not -> if (policy == LivenessPolicy.FAIR_PLAY) "(!${translate(e.x)})"
            else "(lift1 (! ·) ${translate(e.x)})"

            else -> if (policy == LivenessPolicy.FAIR_PLAY) "true" else "(some true)"
        }
        return translate(e)
    }

    private fun toLeanType(t: Type): String = when (t) {
        is Type.IntType -> "Int"
        is Type.BoolType -> "Bool"
        is Type.RangeType -> "Int"
    }
}
