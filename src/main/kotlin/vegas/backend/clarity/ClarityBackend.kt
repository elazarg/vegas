package vegas.backend.clarity

import vegas.RoleId
import vegas.FieldRef
import vegas.semantics.Label
import vegas.semantics.PlayTag
import vegas.backend.clarity.ClarityCompiler
import vegas.ir.*

data class ClarityOptions(
    val clarityVersion: Int = 4,
    val defaultTimeout: Long = 100
)

class ClarityBackend(val game: GameIR, val options: ClarityOptions = ClarityOptions()) {
    private val protocol = ClarityCompiler.compile(game, options.defaultTimeout)
    private val sb = StringBuilder()

    // Assign unique ID to each action for on-chain map
    private val actionIds: Map<ActionId, Int> = protocol.actions
        .mapIndexed { index, action -> action.id to index }
        .toMap()

    fun generate(): String {
        sb.appendLine(";; ${game.name} - Generated by Vegas Clarity Backend")
        sb.appendLine()

        generateConstants()
        generateDataVars()
        generateMaps()
        generateHelpers()
        generateRegistration()
        generateActions()
        generateTimeout()
        generateWithdraw()

        return sb.toString()
    }

    private fun generateConstants() {
        sb.appendLine(";; Constants")
        sb.appendLine("(define-constant ERR_NOT_INITIALIZED (err u100))")
        sb.appendLine("(define-constant ERR_ALREADY_INITIALIZED (err u101))")
        sb.appendLine("(define-constant ERR_WRONG_ROLE (err u102))")
        sb.appendLine("(define-constant ERR_NOT_OPEN (err u103))") // Used for payoffs distributed or wrong state
        sb.appendLine("(define-constant ERR_TIMEOUT_NOT_READY (err u104))")
        sb.appendLine("(define-constant ERR_NOTHING_TO_WITHDRAW (err u105))")
        sb.appendLine("(define-constant ERR_INVALID_PARAM (err u106))")
        sb.appendLine("(define-constant ERR_COMMIT_MISMATCH (err u107))")
        sb.appendLine("(define-constant ERR_ACTION_ALREADY_DONE (err u108))")
        sb.appendLine("(define-constant ERR_DEPENDENCY_NOT_MET (err u109))")
        sb.appendLine()
    }

    private fun generateDataVars() {
        sb.appendLine(";; Data Variables")
        sb.appendLine("(define-data-var initialized bool false)")
        sb.appendLine("(define-data-var last-progress uint u0)")
        sb.appendLine("(define-data-var payoffs-distributed bool false)")
        sb.appendLine()

        // Role bindings
        protocol.roles.forEach { role ->
            sb.appendLine("(define-data-var role-${kebab(role.name)} (optional principal) none)")
            sb.appendLine("(define-data-var deposit-${kebab(role.name)} uint u0)")
        }
        sb.appendLine("(define-data-var total-pot uint u0)")
        sb.appendLine()

        // State variables (commits and values)
        // We iterate actions to find writes.
        // Multiple actions might write same field? No, SSA-ish.
        // But field names should be unique or per-role-param.
        // ClarityStateVar names are owner-param.

        val declaredVars = mutableSetOf<String>()

        protocol.actions.flatMap { it.writes }.forEach { write ->
            if (write.name !in declaredVars) {
                declaredVars.add(write.name)
                val varName = if (write.isCommit) "commit-${kebab(write.name)}" else "var-${kebab(write.name)}"
                val type = if (write.isCommit) "(optional (buff 32))" else toClarityType(write.type)
                val init = if (write.isCommit) "none" else defaultInit(write.type)
                sb.appendLine("(define-data-var $varName $type $init)")
            }
        }
        sb.appendLine()
    }

    private fun generateMaps() {
        sb.appendLine(";; Maps")
        sb.appendLine("(define-map action-done uint bool)")
        sb.appendLine("(define-map claims principal uint)")
        sb.appendLine()
    }

    private fun generateHelpers() {
        sb.appendLine(";; Helpers")

        // Time helper
        sb.appendLine("(define-read-only (get-time)")
        if (options.clarityVersion >= 4) {
             sb.appendLine("    stacks-block-time")
        } else {
             sb.appendLine("    stacks-block-height")
        }
        sb.appendLine(")")
        sb.appendLine()

        // Check timeout helper
        sb.appendLine("""
            (define-private (check-timeout (delta uint))
                (>= (get-time) (+ (var-get last-progress) delta))
            )
        """.trimIndent())

        // Verify commit helper
        sb.appendLine("""
            (define-private (verify-commit (val (buff 128)) (salt (buff 32)) (comm (buff 32)))
                (is-eq (sha256 (concat val salt)) comm)
            )
        """.trimIndent())

        // Is done helper
        sb.appendLine("""
            (define-private (is-done (id uint))
                (default-to false (map-get? action-done id))
            )
        """.trimIndent())
    }

    private fun generateRegistration() {
        sb.appendLine(";; Registration")
        protocol.roles.forEach { role ->
            val roleName = kebab(role.name)
            // find deposit from game DAG directly as ClarityGame pot is total
            // We can look up deposit from ActionDag join steps
            val joinDeposit = game.dag.deposit(role)
            val depositAmount = joinDeposit?.asInt() ?: 0

            sb.appendLine("(define-public (register-$roleName)")
            sb.appendLine("    (begin")
            sb.appendLine("        (asserts! (is-none (var-get role-$roleName)) ERR_ALREADY_INITIALIZED)")

            if (depositAmount > 0) {
                 if (options.clarityVersion >= 4) {
                     sb.appendLine("        (try! (stx-transfer? u$depositAmount tx-sender (as-contract tx-sender)))")
                 } else {
                     sb.appendLine("        (try! (stx-transfer? u$depositAmount tx-sender (as-contract tx-sender)))")
                 }
                 sb.appendLine("        (var-set total-pot (+ (var-get total-pot) u$depositAmount))")
                 sb.appendLine("        (var-set deposit-$roleName u$depositAmount)")
            }

            sb.appendLine("        (var-set role-$roleName (some tx-sender))")
            sb.appendLine("        (check-initialization)")
            sb.appendLine("        (ok true)")
            sb.appendLine("    )")
            sb.appendLine(")")
            sb.appendLine()
        }

        // Check initialization
        sb.appendLine("(define-private (check-initialization)")
        sb.append("    (if (and")
        protocol.roles.forEach { role ->
            sb.append(" (is-some (var-get role-${kebab(role.name)}))")
        }
        sb.append(")")
        sb.appendLine()
        sb.appendLine("        (begin")
        sb.appendLine("            (var-set initialized true)")
        sb.appendLine("            (var-set last-progress (get-time))")
        sb.appendLine("        )")
        sb.appendLine("        true")
        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateActions() {
        sb.appendLine(";; Actions")

        protocol.actions.forEach { action ->
            val actionIdUint = actionIds[action.id]!!
            val actionName = "action-${kebab(action.owner.name)}-${action.id.second}"

            // Params
            val funcParams = mutableListOf<String>()
            val paramChecks = mutableListOf<String>()
            val updates = mutableListOf<String>()

            action.params.forEach { param ->
                val type = toClarityType(param.type)
                if (param.isSalt) {
                    funcParams.add("(${param.name} $type)")
                    funcParams.add("(${param.name}-salt (buff 32))")
                } else {
                    if (action.type is ActionType.Commit) {
                        funcParams.add("(${param.name} (buff 32))")
                    } else {
                        funcParams.add("(${param.name} $type)")
                    }
                }
            }

            // Logic
            if (action.type is ActionType.Commit) {
                // Store commit
                action.writes.forEachIndexed { i, write ->
                    // Assuming params match writes order? ActionSpec params and writes are mapped.
                    val paramName = action.params[i].name
                    updates.add("(var-set commit-${kebab(write.name)} (some $paramName))")
                }
            } else if (action.type is ActionType.Reveal) {
                // Verify and Store value
                action.writes.forEachIndexed { i, write ->
                    val paramName = action.params[i].name
                    val saltName = "$paramName-salt"

                    paramChecks.add("""
                        (asserts! (verify-commit
                            (unwrap-panic (to-consensus-buff? $paramName))
                            $saltName
                            (unwrap-panic (var-get commit-${kebab(write.name)}))
                        ) ERR_COMMIT_MISMATCH)
                    """.trimIndent())

                    updates.add("(var-set var-${kebab(write.name)} $paramName)")
                }
            } else {
                // Public
                action.writes.forEachIndexed { i, write ->
                    val paramName = action.params[i].name
                    updates.add("(var-set var-${kebab(write.name)} $paramName)")
                }
            }

            // Domain checks for params (SetType)
            action.params.forEach { p ->
                if (p.type is Type.SetType && !(action.type is ActionType.Commit)) { // Don't check domain on commit hash
                     val setType = p.type as Type.SetType
                     val checks = setType.values.joinToString(" ") { "(is-eq ${p.name} $it)" }
                     paramChecks.add("(asserts! (or $checks) ERR_INVALID_PARAM)")
                }
            }

            sb.appendLine("(define-public ($actionName ${funcParams.joinToString(" ")} )")
            sb.appendLine("    (begin")
            sb.appendLine("        (asserts! (var-get initialized) ERR_NOT_INITIALIZED)")
            sb.appendLine("        (asserts! (not (var-get payoffs-distributed)) ERR_NOT_OPEN)")
            sb.appendLine("        (asserts! (is-eq (some tx-sender) (var-get role-${kebab(action.owner.name)})) ERR_WRONG_ROLE)")

            // Dependency Check
            sb.appendLine("        (asserts! (not (is-done u$actionIdUint)) ERR_ACTION_ALREADY_DONE)")
            action.prereqs.forEach { prereq ->
                val pid = actionIds[prereq]!!
                sb.appendLine("        (asserts! (is-done u$pid) ERR_DEPENDENCY_NOT_MET)")
            }

            // Param Checks
            paramChecks.forEach { sb.appendLine("        $it") }

            // Updates
            updates.forEach { sb.appendLine("        $it") }

            // Mark Done
            sb.appendLine("        (map-set action-done u$actionIdUint true)")
            sb.appendLine("        (var-set last-progress (get-time))")
            sb.appendLine("        (ok true)")
            sb.appendLine("    )")
            sb.appendLine(")")
            sb.appendLine()
        }
    }

    private fun generateTimeout() {
        sb.appendLine(";; Timeout")
        sb.appendLine("(define-public (timeout)")
        sb.appendLine("    (begin")
        sb.appendLine("        (asserts! (var-get initialized) ERR_NOT_INITIALIZED)")
        sb.appendLine("        (asserts! (not (var-get payoffs-distributed)) ERR_ALREADY_INITIALIZED)")

        // Structural check: Check global timeout condition
        // Use defaultTimeout from options.
        sb.appendLine("        (asserts! (check-timeout u${options.defaultTimeout}) ERR_TIMEOUT_NOT_READY)")

        // Rules logic
        // (if (and (is-done A) (not (is-done B))) (pay...)
        // (if ...) ...)

        if (protocol.timeoutRules.isEmpty()) {
             sb.appendLine("        (err ERR_NOT_OPEN)")
        } else {
             var expr = "(err ERR_NOT_OPEN)" // Fallback if no rule matches (shouldn't happen if rules cover all)

             // Iterate reversed to build if-else chain?
             // Logic: Rules are sorted by required size descending (most specific first).
             // First match wins.
             // So: (if Rule1 ... (if Rule2 ...))

             for (rule in protocol.timeoutRules.reversed()) {
                 // Build pay block
                 val payBlock = StringBuilder()
                 payBlock.append("(begin ")
                 rule.payoff.forEach { (role, amt) ->
                     if (amt > 0) {
                         payBlock.append("(map-set claims (unwrap-panic (var-get role-${kebab(role.name)})) u$amt) ")
                     }
                 }
                 payBlock.append("(var-set payoffs-distributed true) (ok true))")

                 // Build condition
                 // (and (is-done r1) ... (not (is-done f1)) ...)
                 val conditions = mutableListOf<String>()
                 rule.required.forEach { id -> conditions.add("(is-done u${actionIds[id]!!})") }
                 rule.forbidden.forEach { id -> conditions.add("(not (is-done u${actionIds[id]!!}))") }

                 val condExpr = if (conditions.isEmpty()) "true" else if (conditions.size == 1) conditions[0] else "(and ${conditions.joinToString(" ")})"

                 expr = "(if $condExpr $payBlock $expr)"
             }
             sb.appendLine("        $expr")
        }

        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateWithdraw() {
        sb.appendLine(";; Withdraw")
        sb.appendLine("(define-public (withdraw)")
        sb.appendLine("    (let (")
        sb.appendLine("        (recipient tx-sender)")
        sb.appendLine("        (amt (default-to u0 (map-get? claims recipient)))")
        sb.appendLine("    )")
        sb.appendLine("        (asserts! (> amt u0) ERR_NOTHING_TO_WITHDRAW)")
        sb.appendLine("        (map-set claims recipient u0)")

        if (options.clarityVersion >= 4) {
            // Clarity 4: as-contract? with explicit outflow
            // (try! (as-contract? (stx-transfer? amt tx-sender recipient) (with-stx amt)))
            // Note: stx-transfer? sender must be tx-sender (contract).
            // (as-contract? (stx-transfer? ...))
            // wait, as-contract? syntax: (as-contract? (expr) (allowance...))
            // The expr is (stx-transfer? ...)
            sb.appendLine("        (try! (as-contract? (stx-transfer? amt tx-sender recipient) (with-stx amt)))")
        } else {
            // Clarity 3: as-contract
            sb.appendLine("        (try! (as-contract (stx-transfer? amt tx-sender recipient)))")
        }

        sb.appendLine("        (ok amt)")
        sb.appendLine("    )")
        sb.appendLine(")")
    }

    // Utils
    private fun kebab(s: String): String = s.fold(StringBuilder()) { acc, c ->
        if (c.isUpperCase()) {
            if (acc.isNotEmpty()) acc.append('-')
            acc.append(c.lowercaseChar())
        } else {
            acc.append(c)
        }
    }.toString()

    private fun defaultInit(t: Type): String = when(t) {
        Type.IntType -> "0"
        Type.BoolType -> "false"
        is Type.SetType -> "${t.values.first()}"
    }

    private fun toClarityType(t: Type): String = when(t) {
        Type.IntType -> "int"
        Type.BoolType -> "bool"
        is Type.SetType -> "int"
    }
}

fun genClarity(game: GameIR, opt: ClarityOptions = ClarityOptions()): String {
    return ClarityBackend(game, opt).generate()
}
