package vegas.backend.clarity

import vegas.RoleId
import vegas.FieldRef
import vegas.VarId
import vegas.backend.clarity.ClarityCompiler
import vegas.ir.*

data class ClarityOptions(
    val clarityVersion: Int = 4,
    val defaultTimeout: Long = 100
)

class ClarityBackend(val game: GameIR, val options: ClarityOptions = ClarityOptions()) {
    private val protocol = ClarityCompiler.compile(game, options.defaultTimeout)
    private val sb = StringBuilder()

    // Assign unique ID to each action for on-chain map
    private val actionIds: Map<ActionId, Int> = protocol.actions
        .mapIndexed { index, action -> action.id to index }
        .toMap()

    // Map FieldRef to list of ActionIds (uints) that write it
    private val fieldWriters: Map<FieldRef, List<Int>> by lazy {
        val map = mutableMapOf<FieldRef, MutableList<Int>>()
        protocol.actions.forEach { action ->
            val aid = actionIds[action.id]!!
            game.dag.writes(action.id).forEach { field ->
                map.getOrPut(field) { mutableListOf() }.add(aid)
            }
        }
        map
    }

    fun generate(): String {
        sb.appendLine(";; ${game.name} - Generated by Vegas Clarity Backend")
        sb.appendLine()

        generateConstants()
        generateDataVars()
        generateMaps()
        generateHelpers()
        generateRegistration()
        generateActions()
        generateFinalize()
        generateTimeout()
        generateWithdraw()

        return sb.toString()
    }

    private fun generateConstants() {
        sb.appendLine(";; Constants")
        sb.appendLine("(define-constant ERR_NOT_INITIALIZED (err u100))")
        sb.appendLine("(define-constant ERR_ALREADY_INITIALIZED (err u101))")
        sb.appendLine("(define-constant ERR_WRONG_ROLE (err u102))")
        sb.appendLine("(define-constant ERR_NOT_OPEN (err u103))")
        sb.appendLine("(define-constant ERR_TIMEOUT_NOT_READY (err u104))")
        sb.appendLine("(define-constant ERR_NOTHING_TO_WITHDRAW (err u105))")
        sb.appendLine("(define-constant ERR_INVALID_PARAM (err u106))")
        sb.appendLine("(define-constant ERR_COMMIT_MISMATCH (err u107))")
        sb.appendLine("(define-constant ERR_ACTION_ALREADY_DONE (err u108))")
        sb.appendLine("(define-constant ERR_DEPENDENCY_NOT_MET (err u109))")
        sb.appendLine("(define-constant ERR_GUARD_FAILED (err u110))")
        sb.appendLine("(define-constant ERR_PAYOUT_TOO_HIGH (err u111))")
        sb.appendLine()
    }

    private fun generateDataVars() {
        sb.appendLine(";; Data Variables")
        sb.appendLine("(define-data-var initialized bool false)")
        sb.appendLine("(define-data-var last-progress uint u0)")
        sb.appendLine("(define-data-var payoffs-distributed bool false)")
        sb.appendLine()

        // Role bindings
        protocol.roles.forEach { role ->
            sb.appendLine("(define-data-var role-${kebab(role.name)} (optional principal) none)")
            sb.appendLine("(define-data-var deposit-${kebab(role.name)} uint u0)")
        }
        sb.appendLine("(define-data-var total-pot uint u0)")
        sb.appendLine()

        // State variables
        val declaredVars = mutableSetOf<String>()

        protocol.actions.flatMap { it.writes }.forEach { write ->
            val varName = if (write.isCommit) "commit-${kebab(write.name)}" else "var-${kebab(write.name)}"
            if (varName !in declaredVars) {
                declaredVars.add(varName)
                val type = if (write.isCommit) "(optional (buff 32))" else toClarityType(write.type)
                val init = if (write.isCommit) "none" else defaultInit(write.type)
                sb.appendLine("(define-data-var $varName $type $init)")
            }
        }
        sb.appendLine()
    }

    private fun generateMaps() {
        sb.appendLine(";; Maps")
        sb.appendLine("(define-map action-done uint bool)")
        sb.appendLine("(define-map claims principal uint)")
        sb.appendLine()
    }

    private fun generateHelpers() {
        sb.appendLine(";; Helpers")

        sb.appendLine("(define-read-only (get-time)")
        if (options.clarityVersion >= 4) {
             sb.appendLine("    stacks-block-time")
        } else {
             sb.appendLine("    stacks-block-height")
        }
        sb.appendLine(")")
        sb.appendLine()

        sb.appendLine("""
            (define-private (check-timeout (delta uint))
                (>= (get-time) (+ (var-get last-progress) delta))
            )
        """.trimIndent())

        sb.appendLine("""
            (define-private (verify-commit (val (buff 128)) (salt (buff 32)) (comm (buff 32)))
                (is-eq (sha256 (concat val salt)) comm)
            )
        """.trimIndent())

        sb.appendLine("""
            (define-private (is-done (id uint))
                (default-to false (map-get? action-done id))
            )
        """.trimIndent())
    }

    private fun generateRegistration() {
        sb.appendLine(";; Registration")
        protocol.roles.forEach { role ->
            val roleName = kebab(role.name)
            val joinDeposit = game.dag.deposit(role)
            val depositAmount = joinDeposit?.asInt() ?: 0

            sb.appendLine("(define-public (register-$roleName)")
            sb.appendLine("    (begin")
            sb.appendLine("        (asserts! (is-none (var-get role-$roleName)) ERR_ALREADY_INITIALIZED)")

            if (depositAmount > 0) {
                 if (options.clarityVersion >= 4) {
                     sb.appendLine("        (try! (stx-transfer? u$depositAmount tx-sender (unwrap-panic (as-contract tx-sender))))")
                 } else {
                     sb.appendLine("        (try! (stx-transfer? u$depositAmount tx-sender (as-contract tx-sender)))")
                 }
                 sb.appendLine("        (var-set total-pot (+ (var-get total-pot) u$depositAmount))")
                 sb.appendLine("        (var-set deposit-$roleName u$depositAmount)")
            }

            sb.appendLine("        (var-set role-$roleName (some tx-sender))")
            sb.appendLine("        (check-initialization)")
            sb.appendLine("        (ok true)")
            sb.appendLine("    )")
            sb.appendLine(")")
            sb.appendLine()
        }

        sb.appendLine("(define-private (check-initialization)")
        sb.append("    (if (and")
        protocol.roles.forEach { role ->
            sb.append(" (is-some (var-get role-${kebab(role.name)}))")
        }
        sb.append(")")
        sb.appendLine()
        sb.appendLine("        (begin")
        sb.appendLine("            (var-set initialized true)")
        sb.appendLine("            (var-set last-progress (get-time))")
        sb.appendLine("        )")
        sb.appendLine("        true")
        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateActions() {
        sb.appendLine(";; Actions")

        protocol.actions.forEach { action ->
            val actionIdUint = actionIds[action.id]!!
            val actionName = "action-${kebab(action.owner.name)}-${action.id.second}"

            val funcParams = mutableListOf<String>()
            val paramChecks = mutableListOf<String>()
            val updates = mutableListOf<String>()

            val localParams = mutableMapOf<FieldRef, String>()

            action.params.forEach { param ->
                val type = toClarityType(param.type)
                localParams[FieldRef(action.owner, VarId(param.name))] = param.name

                if (param.isSalt) {
                    funcParams.add("(${param.name} $type)")
                    funcParams.add("(${param.name}-salt (buff 32))")
                } else {
                    if (action.type is ActionType.Commit) {
                        funcParams.add("(${param.name} (buff 32))")
                    } else {
                        funcParams.add("(${param.name} $type)")
                    }
                }
            }

            if (action.type is ActionType.Commit) {
                action.writes.forEachIndexed { i, write ->
                    val paramName = action.params[i].name
                    updates.add("(var-set commit-${kebab(write.name)} (some $paramName))")
                }
            } else if (action.type is ActionType.Reveal) {
                action.writes.forEachIndexed { i, write ->
                    val paramName = action.params[i].name
                    val saltName = "$paramName-salt"
                    paramChecks.add("""
                        (asserts! (verify-commit
                            (unwrap-panic (to-consensus-buff? $paramName))
                            $saltName
                            (unwrap-panic (var-get commit-${kebab(write.name)}))
                        ) ERR_COMMIT_MISMATCH)
                    """.trimIndent())
                    updates.add("(var-set var-${kebab(write.name)} $paramName)")
                }
            } else {
                action.writes.forEachIndexed { i, write ->
                    val paramName = action.params[i].name
                    updates.add("(var-set var-${kebab(write.name)} $paramName)")
                }
            }

            action.params.forEach { p ->
                if (p.type is Type.SetType && !(action.type is ActionType.Commit)) {
                     val setType = p.type as Type.SetType
                     val checks = setType.values.joinToString(" ") { "(is-eq ${p.name} $it)" }
                     paramChecks.add("(asserts! (or $checks) ERR_INVALID_PARAM)")
                }
            }

            sb.appendLine("(define-public ($actionName ${funcParams.joinToString(" ")} )")
            sb.appendLine("    (begin")
            sb.appendLine("        (asserts! (var-get initialized) ERR_NOT_INITIALIZED)")
            sb.appendLine("        (asserts! (not (var-get payoffs-distributed)) ERR_NOT_OPEN)")
            sb.appendLine("        (asserts! (is-eq (some tx-sender) (var-get role-${kebab(action.owner.name)})) ERR_WRONG_ROLE)")

            sb.appendLine("        (asserts! (not (is-done u$actionIdUint)) ERR_ACTION_ALREADY_DONE)")
            action.prereqs.forEach { prereq ->
                val pid = actionIds[prereq]!!
                sb.appendLine("        (asserts! (is-done u$pid) ERR_DEPENDENCY_NOT_MET)")
            }

            if (action.guard != null) {
                sb.appendLine("        (asserts! ${translateExpr(action.guard, ::getFieldWriters, localParams)} ERR_GUARD_FAILED)")
            }

            paramChecks.forEach { sb.appendLine("        $it") }
            updates.forEach { sb.appendLine("        $it") }

            sb.appendLine("        (map-set action-done u$actionIdUint true)")
            sb.appendLine("        (var-set last-progress (get-time))")
            sb.appendLine("        (ok true)")
            sb.appendLine("    )")
            sb.appendLine(")")
            sb.appendLine()
        }
    }

    private fun generateFinalize() {
        sb.appendLine(";; Finalize")
        sb.appendLine("(define-public (finalize)")
        sb.appendLine("    (begin")
        sb.appendLine("        (asserts! (var-get initialized) ERR_NOT_INITIALIZED)")
        sb.appendLine("        (asserts! (not (var-get payoffs-distributed)) ERR_ALREADY_INITIALIZED)")

        val conds = protocol.terminalFrontiers.map { doneSet ->
            if (doneSet.isEmpty()) "true" else {
                val checks = doneSet.map { id -> "(is-done u${actionIds[id]!!})" }
                if (checks.size == 1) checks[0] else "(and ${checks.joinToString(" ")})"
            }
        }
        val terminalCond = if (conds.isEmpty()) "false" else if (conds.size == 1) conds[0] else "(or ${conds.joinToString(" ")})"

        sb.appendLine("        (asserts! $terminalCond ERR_NOT_OPEN)")

        protocol.payoffs.forEach { (role, expr) ->
            val amountExpr = translateExpr(expr, ::getFieldWriters)
            sb.appendLine("        (map-set claims (unwrap-panic (var-get role-${kebab(role.name)})) $amountExpr)")
        }

        sb.appendLine("        (var-set payoffs-distributed true)")
        sb.appendLine("        (ok true)")
        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateTimeout() {
        sb.appendLine(";; Timeout")
        sb.appendLine("(define-public (timeout)")
        sb.appendLine("    (begin")
        sb.appendLine("        (asserts! (var-get initialized) ERR_NOT_INITIALIZED)")
        sb.appendLine("        (asserts! (not (var-get payoffs-distributed)) ERR_ALREADY_INITIALIZED)")
        sb.appendLine("        (asserts! (check-timeout u${options.defaultTimeout}) ERR_TIMEOUT_NOT_READY)")

        if (protocol.timeoutRules.isEmpty()) {
             sb.appendLine("        (err ERR_NOT_OPEN)")
        } else {
             var expr = "(err ERR_NOT_OPEN)"

             for (rule in protocol.timeoutRules.reversed()) {
                 val payBlock = StringBuilder()
                 payBlock.append("(begin ")
                 rule.payoff.forEach { (role, amt) ->
                     if (amt > 0) {
                         payBlock.append("(map-set claims (unwrap-panic (var-get role-${kebab(role.name)})) u$amt) ")
                     }
                 }
                 payBlock.append("(var-set payoffs-distributed true) (ok true))")

                 val conditions = mutableListOf<String>()
                 rule.required.forEach { id -> conditions.add("(is-done u${actionIds[id]!!})") }
                 rule.forbidden.forEach { id -> conditions.add("(not (is-done u${actionIds[id]!!}))") }

                 val condExpr = if (conditions.isEmpty()) "true" else if (conditions.size == 1) conditions[0] else "(and ${conditions.joinToString(" ")})"

                 expr = "(if $condExpr $payBlock $expr)"
             }
             sb.appendLine("        $expr")
        }

        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateWithdraw() {
        sb.appendLine(";; Withdraw")
        sb.appendLine("(define-public (withdraw)")
        sb.appendLine("    (let (")
        sb.appendLine("        (recipient tx-sender)")
        sb.appendLine("        (amt (default-to u0 (map-get? claims recipient)))")
        sb.appendLine("    )")
        sb.appendLine("        (asserts! (> amt u0) ERR_NOTHING_TO_WITHDRAW)")
        sb.appendLine("        (map-set claims recipient u0)")

        if (options.clarityVersion >= 4) {
            sb.appendLine("        (try! (as-contract? (stx-transfer? amt tx-sender recipient) (with-stx amt)))")
        } else {
            sb.appendLine("        (try! (as-contract (stx-transfer? amt tx-sender recipient)))")
        }

        sb.appendLine("        (ok amt)")
        sb.appendLine("    )")
        sb.appendLine(")")
    }

    // Utils
    private fun getFieldWriters(f: FieldRef): List<Int> {
        return fieldWriters[f] ?: emptyList()
    }

    private fun kebab(s: String): String = s.fold(StringBuilder()) { acc, c ->
        if (c.isUpperCase()) {
            if (acc.isNotEmpty()) acc.append('-')
            acc.append(c.lowercaseChar())
        } else {
            acc.append(c)
        }
    }.toString()

    private fun defaultInit(t: Type): String = when(t) {
        Type.IntType -> "0"
        Type.BoolType -> "false"
        is Type.SetType -> "${t.values.first()}"
    }

    private fun toClarityType(t: Type): String = when(t) {
        Type.IntType -> "int"
        Type.BoolType -> "bool"
        is Type.SetType -> "int"
    }
}

fun genClarity(game: GameIR, opt: ClarityOptions = ClarityOptions()): String {
    return ClarityBackend(game, opt).generate()
}
