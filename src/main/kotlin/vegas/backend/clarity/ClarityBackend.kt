package vegas.backend.clarity

import vegas.RoleId
import vegas.FieldRef
import vegas.semantics.Label
import vegas.semantics.PlayTag
import vegas.backend.clarity.ClarityCompiler
import vegas.ir.*

data class ClarityOptions(
    val clarityVersion: Int = 4,
    val defaultTimeout: Long = 100 // Default timeout delta
)

class ClarityBackend(val game: GameIR, val options: ClarityOptions = ClarityOptions()) {
    private val protocol = ClarityCompiler.compile(game, options.defaultTimeout)
    private val sb = StringBuilder()

    // Mapping from (ActionId) to function name
    private val actionFuncNames = mutableMapOf<ActionId, String>()

    fun generate(): String {
        sb.appendLine(";; ${game.name} - Generated by Vegas Clarity Backend")
        sb.appendLine()

        generateConstants()
        generateDataVars()
        generateMaps()
        generateHelpers()
        generateRegistration()
        generateActions()
        generateTimeout()
        generateWithdraw()

        return sb.toString()
    }

    private fun generateConstants() {
        sb.appendLine(";; Constants")
        sb.appendLine("(define-constant ERR_NOT_INITIALIZED (err u100))")
        sb.appendLine("(define-constant ERR_ALREADY_INITIALIZED (err u101))")
        sb.appendLine("(define-constant ERR_WRONG_ROLE (err u102))")
        sb.appendLine("(define-constant ERR_WRONG_STATE (err u103))")
        sb.appendLine("(define-constant ERR_NOT_OPEN (err u104))")
        sb.appendLine("(define-constant ERR_TIMEOUT_NOT_READY (err u105))")
        sb.appendLine("(define-constant ERR_NOTHING_TO_WITHDRAW (err u106))")
        sb.appendLine("(define-constant ERR_INVALID_PARAM (err u107))")
        sb.appendLine("(define-constant ERR_COMMIT_MISMATCH (err u108))")
        sb.appendLine()
    }

    private fun generateDataVars() {
        sb.appendLine(";; Data Variables")
        sb.appendLine("(define-data-var initialized bool false)")
        sb.appendLine("(define-data-var state uint u${protocol.rootStateId})")
        sb.appendLine("(define-data-var last-progress uint u0)")
        sb.appendLine("(define-data-var payoffs-distributed bool false)")
        sb.appendLine()

        // Role bindings
        protocol.roles.forEach { role ->
            sb.appendLine("(define-data-var role-${kebab(role.name)} (optional principal) none)")
            sb.appendLine("(define-data-var deposit-${kebab(role.name)} uint u0)")
        }
        sb.appendLine("(define-data-var total-pot uint u0)")
        sb.appendLine()

        // Game variables (fields)
        // We iterate over all actions to find written fields and their types
        val fields = mutableMapOf<FieldRef, Type>()
        game.dag.actions.forEach { actionId ->
            val spec = game.dag.spec(actionId)
            val owner = game.dag.owner(actionId)
            spec.params.forEach { param ->
                fields[FieldRef(owner, param.name)] = param.type
            }
        }

        // Also check visibility to decide storage type
        // If COMMIT exists for a field, we need a commitment var
        // If PUBLIC or REVEAL exists, we need a value var
        val commitVars = mutableSetOf<FieldRef>()
        val valueVars = mutableSetOf<FieldRef>()

        game.dag.actions.forEach { actionId ->
            val vis = game.dag.visibilityOf(actionId)
            vis.forEach { (field, v) ->
                when (v) {
                    Visibility.COMMIT -> commitVars.add(field)
                    Visibility.REVEAL -> valueVars.add(field) // Stored after reveal
                    Visibility.PUBLIC -> valueVars.add(field)
                }
            }
        }

        valueVars.forEach { field ->
            val type = fields[field] ?: Type.IntType
            val init = defaultInit(type)
            val clarType = toClarityType(type)
            sb.appendLine("(define-data-var var-${kebab(field.owner.name)}-${kebab(field.param.name)} $clarType $init)")
        }

        commitVars.forEach { field ->
            sb.appendLine("(define-data-var commit-${kebab(field.owner.name)}-${kebab(field.param.name)} (buff 32) 0x)")
        }
        sb.appendLine()
    }

    private fun generateMaps() {
        sb.appendLine(";; Claims Map")
        sb.appendLine("(define-map claims principal uint)")
        sb.appendLine()
    }

    private fun generateHelpers() {
        sb.appendLine(";; Helpers")

        // Time helper
        sb.appendLine("(define-read-only (get-time)")
        if (options.clarityVersion >= 4) {
             sb.appendLine("    stacks-block-time")
        } else {
             sb.appendLine("    stacks-block-height")
        }
        sb.appendLine(")")
        sb.appendLine()

        // Check timeout helper
        sb.appendLine("""
            (define-private (check-timeout (delta uint))
                (>= (get-time) (+ (var-get last-progress) delta))
            )
        """.trimIndent())

        // Verify commit helper
        sb.appendLine("""
            (define-private (verify-commit (val (buff 128)) (salt (buff 32)) (comm (buff 32)))
                (is-eq (sha256 (concat val salt)) comm)
            )
        """.trimIndent())
    }

    private fun generateRegistration() {
        sb.appendLine(";; Registration")
        protocol.roles.forEach { role ->
            val roleName = kebab(role.name)
            val joinDeposit = game.dag.deposit(role)
            val depositAmount = joinDeposit?.asInt() ?: 0

            sb.appendLine("(define-public (register-$roleName)")
            sb.appendLine("    (begin")
            sb.appendLine("        (asserts! (is-none (var-get role-$roleName)) ERR_ALREADY_INITIALIZED)")

            if (depositAmount > 0) {
                 sb.appendLine("        (try! (stx-transfer? u$depositAmount tx-sender (as-contract tx-sender)))")
                 sb.appendLine("        (var-set total-pot (+ (var-get total-pot) u$depositAmount))")
                 sb.appendLine("        (var-set deposit-$roleName u$depositAmount)")
            }

            sb.appendLine("        (var-set role-$roleName (some tx-sender))")
            sb.appendLine("        (check-initialization)")
            sb.appendLine("        (ok true)")
            sb.appendLine("    )")
            sb.appendLine(")")
            sb.appendLine()
        }

        // Check initialization
        sb.appendLine("(define-private (check-initialization)")
        sb.append("    (if (and")
        protocol.roles.forEach { role ->
            sb.append(" (is-some (var-get role-${kebab(role.name)}))")
        }
        sb.append(")")
        sb.appendLine()
        sb.appendLine("        (begin")
        sb.appendLine("            (var-set initialized true)")
        sb.appendLine("            (var-set last-progress (get-time))")
        sb.appendLine("        )")
        sb.appendLine("        true")
        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateActions() {
        sb.appendLine(";; Actions")

        // Group transitions by ActionId to handle actions that work in multiple states
        val transitionsByAction = mutableMapOf<ActionId, MutableList<Pair<Int, Int>>>() // ActionId -> List<(FromState, ToState)>

        for (state in protocol.states.values) {
            for (trans in state.transitions) {
                if (trans.label is Label.Play) {
                     val tag = trans.label.tag
                     if (tag is PlayTag.Action) {
                         transitionsByAction.getOrPut(tag.actionId) { mutableListOf() }.add(state.id to trans.nextStateId)
                     }
                }
            }
        }

        val sortedActions = transitionsByAction.keys.sortedBy { it.second } // Sort by action index

        for (actionId in sortedActions) {
            val validTransitions = transitionsByAction[actionId]!!.distinct()
            generateActionFunc(actionId, validTransitions)
        }
    }

    private fun generateActionFunc(actionId: ActionId, validTransitions: List<Pair<Int, Int>>) {
        val role = game.dag.owner(actionId)
        val spec = game.dag.spec(actionId)
        val visibility = game.dag.visibilityOf(actionId)
        val actionName = "action-${kebab(role.name)}-${actionId.second}"
        actionFuncNames[actionId] = actionName

        // Parameters
        val funcParams = mutableListOf<String>()
        val paramChecks = mutableListOf<String>()
        val updates = mutableListOf<String>()

        spec.params.forEach { param ->
            val fieldRef = FieldRef(role, param.name)
            val vis = visibility[fieldRef]!!

            when (vis) {
                Visibility.COMMIT -> {
                    // Pass hash
                    funcParams.add("(${param.name} (buff 32))")
                    // Store hash
                    updates.add("(var-set commit-${kebab(role.name)}-${kebab(param.name.name)} ${param.name})")
                }
                Visibility.REVEAL -> {
                    // Pass value + salt
                    val type = toClarityType(param.type)
                    funcParams.add("(${param.name} $type)")
                    funcParams.add("(${param.name}-salt (buff 32))")

                    // Verify hash
                    paramChecks.add("""
                        (asserts! (verify-commit
                            (unwrap-panic (to-consensus-buff? ${param.name}))
                            ${param.name}-salt
                            (var-get commit-${kebab(role.name)}-${kebab(param.name.name)})
                        ) ERR_COMMIT_MISMATCH)
                    """.trimIndent())

                    // Store value
                    updates.add("(var-set var-${kebab(role.name)}-${kebab(param.name.name)} ${param.name})")
                }
                Visibility.PUBLIC -> {
                    // Pass value
                    val type = toClarityType(param.type)
                    funcParams.add("(${param.name} $type)")

                    // Store value
                    updates.add("(var-set var-${kebab(role.name)}-${kebab(param.name.name)} ${param.name})")
                }
            }

            // Domain check for value
            if (vis != Visibility.COMMIT) {
                 if (param.type is Type.SetType) {
                     val setType = param.type as Type.SetType
                     // (or (is-eq p v1) (is-eq p v2) ...)
                     val checks = setType.values.joinToString(" ") { "(is-eq ${param.name} $it)" }
                     paramChecks.add("(asserts! (or $checks) ERR_INVALID_PARAM)")
                 }
            }
        }

        sb.appendLine("(define-public ($actionName ${funcParams.joinToString(" ")} )")
        sb.appendLine("    (let ((st (var-get state)))")
        sb.appendLine("        (asserts! (var-get initialized) ERR_NOT_INITIALIZED)")
        sb.appendLine("        (asserts! (is-eq (some tx-sender) (var-get role-${kebab(role.name)})) ERR_WRONG_ROLE)")

        // State check
        if (validTransitions.size == 1) {
            val (from, _) = validTransitions[0]
            sb.appendLine("        (asserts! (is-eq st u$from) ERR_WRONG_STATE)")
        } else {
            val check = validTransitions.joinToString(" ") { "(is-eq st u${it.first})" }
            sb.appendLine("        (asserts! (or $check) ERR_WRONG_STATE)")
        }

        // Param/Reveal Checks
        paramChecks.forEach { sb.appendLine("        $it") }

        // Updates
        updates.forEach { sb.appendLine("        $it") }

        // State Transition
        sb.append("        (var-set state ")
        if (validTransitions.size == 1) {
            sb.append("u${validTransitions[0].second}")
        } else {
            // (if (is-eq st uA) uA' (if (is-eq st uB) uB' ...))
            // We assume validTransitions covers all validated states.
            // The last one can be the default branch since we asserted state is valid above.
            var expr = "u${validTransitions.last().second}"
            for (i in validTransitions.indices.reversed().drop(1)) {
                val (from, to) = validTransitions[i]
                expr = "(if (is-eq st u$from) u$to $expr)"
            }
            sb.append(expr)
        }
        sb.appendLine(")")

        sb.appendLine("        (var-set last-progress (get-time))")
        sb.appendLine("        (ok true)")
        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateTimeout() {
        sb.appendLine(";; Timeout")
        sb.appendLine("(define-public (timeout)")
        sb.appendLine("    (let ((st (var-get state)))")
        sb.appendLine("        (asserts! (var-get initialized) ERR_NOT_INITIALIZED)")
        sb.appendLine("        (asserts! (not (var-get payoffs-distributed)) ERR_ALREADY_INITIALIZED)")

        val statesWithPayouts = protocol.states.values.filter { it.abortBalance.isNotEmpty() }

        if (statesWithPayouts.isEmpty()) {
             sb.appendLine("        (err ERR_NOT_OPEN)")
        } else {
             var expr = "(err ERR_WRONG_STATE)"
             for (s in statesWithPayouts.reversed()) {
                 expr = "(if (is-eq st u${s.id}) (resolve-timeout-${s.id}) $expr)"
             }
             sb.appendLine("        $expr")
        }

        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()

        // Generate private resolvers
        statesWithPayouts.forEach { s ->
             sb.appendLine("(define-private (resolve-timeout-${s.id})")
             sb.appendLine("    (begin")

             if (s.activePlayer != null) {
                 sb.appendLine("        (asserts! (check-timeout u${s.timeoutDelta}) ERR_TIMEOUT_NOT_READY)")
             }

             s.abortBalance.forEach { (role, amt) ->
                 if (amt > 0) {
                      sb.appendLine("        (map-set claims (unwrap-panic (var-get role-${kebab(role.name)})) u$amt)")
                 }
             }

             sb.appendLine("        (var-set payoffs-distributed true)")
             sb.appendLine("        (ok true)")
             sb.appendLine("    )")
             sb.appendLine(")")
        }
    }

    private fun generateWithdraw() {
        sb.appendLine(";; Withdraw")
        sb.appendLine("(define-public (withdraw)")
        sb.appendLine("    (let (")
        sb.appendLine("        (recipient tx-sender)")
        sb.appendLine("        (amt (default-to u0 (map-get? claims recipient)))")
        sb.appendLine("    )")
        sb.appendLine("        (asserts! (> amt u0) ERR_NOTHING_TO_WITHDRAW)")
        sb.appendLine("        (map-set claims recipient u0)")
        sb.appendLine("        (try! (as-contract (stx-transfer? amt tx-sender recipient)))")
        sb.appendLine("        (ok amt)")
        sb.appendLine("    )")
        sb.appendLine(")")
    }

    // Utils
    private fun kebab(s: String): String = s.fold(StringBuilder()) { acc, c ->
        if (c.isUpperCase()) {
            if (acc.isNotEmpty()) acc.append('-')
            acc.append(c.lowercaseChar())
        } else {
            acc.append(c)
        }
    }.toString()

    private fun defaultInit(t: Type): String = when(t) {
        Type.IntType -> "0"
        Type.BoolType -> "false"
        is Type.SetType -> "${t.values.first()}"
    }

    private fun toClarityType(t: Type): String = when(t) {
        Type.IntType -> "int"
        Type.BoolType -> "bool"
        is Type.SetType -> "int"
    }
}

fun genClarity(game: GameIR, opt: ClarityOptions = ClarityOptions()): String {
    return ClarityBackend(game, opt).generate()
}
