package vegas.backend.clarity

import vegas.RoleId
import vegas.FieldRef
import vegas.VarId
import vegas.backend.clarity.ClarityCompiler
import vegas.ir.*

data class ClarityOptions(
    val clarityVersion: Int = 4,
    val defaultTimeout: Long = 100
)

class ClarityBackend(val game: GameIR, val options: ClarityOptions = ClarityOptions()) {
    private val protocol = ClarityCompiler.compile(game, options.defaultTimeout)
    private val sb = StringBuilder()

    // Linearly sorted actions (enforcing sequential execution)
    private val sortedActions = protocol.actions

    private val actionIds: Map<ActionId, Int> = sortedActions
        .mapIndexed { index, action -> action.id to index }
        .toMap()

    private val fieldWriters: Map<FieldRef, List<Int>> by lazy {
        val map = mutableMapOf<FieldRef, MutableList<Int>>()
        sortedActions.forEach { action ->
            val aid = actionIds[action.id]!!
            game.dag.writes(action.id).forEach { field ->
                map.getOrPut(field) { mutableListOf() }.add(aid)
            }
        }
        map
    }

    fun generate(): String {
        sb.appendLine(";; ${game.name} - Generated by Vegas Clarity Backend")
        sb.appendLine()

        generateConstants()
        generateDataVars()
        generateMaps()
        generateHelpers()
        generateRegistration()
        generateCancel()
        generateActions()
        generateFinalize()
        generateTimeout()
        generateWithdraw()

        return sb.toString()
    }

    private fun generateConstants() {
        sb.appendLine(";; Constants")
        sb.appendLine("(define-constant ERR_NOT_INITIALIZED (err u100))")
        sb.appendLine("(define-constant ERR_ALREADY_INITIALIZED (err u101))")
        sb.appendLine("(define-constant ERR_WRONG_ROLE (err u102))")
        sb.appendLine("(define-constant ERR_NOT_OPEN (err u103))")
        sb.appendLine("(define-constant ERR_TIMEOUT_NOT_READY (err u104))")
        sb.appendLine("(define-constant ERR_NOTHING_TO_WITHDRAW (err u105))")
        sb.appendLine("(define-constant ERR_INVALID_PARAM (err u106))")
        sb.appendLine("(define-constant ERR_COMMIT_MISMATCH (err u107))")
        sb.appendLine("(define-constant ERR_ACTION_ALREADY_DONE (err u108))")
        sb.appendLine("(define-constant ERR_DEPENDENCY_NOT_MET (err u109))")
        sb.appendLine("(define-constant ERR_GUARD_FAILED (err u110))")
        sb.appendLine("(define-constant ERR_PAYOUT_TOO_HIGH (err u111))")
        sb.appendLine()
    }

    private fun generateDataVars() {
        sb.appendLine(";; Data Variables")
        sb.appendLine("(define-data-var initialized bool false)")
        sb.appendLine("(define-data-var last-progress uint u0)")
        sb.appendLine("(define-data-var first-dep-time uint u0)")
        sb.appendLine("(define-data-var payoffs-distributed bool false)")
        sb.appendLine()

        protocol.roles.forEach { role ->
            sb.appendLine("(define-data-var role-${kebab(role.name)} (optional principal) none)")
            sb.appendLine("(define-data-var deposit-${kebab(role.name)} uint u0)")
        }
        sb.appendLine("(define-data-var total-pot uint u0)")
        sb.appendLine()

        val declaredVars = mutableSetOf<String>()
        sortedActions.flatMap { it.writes }.forEach { write ->
            val varName = if (write.isCommit) "commit-${kebab(write.name)}" else "var-${kebab(write.name)}"
            if (varName !in declaredVars) {
                declaredVars.add(varName)
                val type = if (write.isCommit) "(optional (buff 32))" else toClarityType(write.type)
                val init = if (write.isCommit) "none" else defaultInit(write.type)
                sb.appendLine("(define-data-var $varName $type $init)")
            }
        }
        sb.appendLine()
    }

    private fun generateMaps() {
        sb.appendLine(";; Maps")
        sb.appendLine("(define-map action-done uint bool)")
        sb.appendLine("(define-map claims principal uint)")
        sb.appendLine()
    }

    private fun generateHelpers() {
        sb.appendLine(";; Helpers")
        sb.appendLine("(define-read-only (get-time)")
        if (options.clarityVersion >= 4) {
             sb.appendLine("    stacks-block-time")
        } else {
             sb.appendLine("    stacks-block-height")
        }
        sb.appendLine(")")
        sb.appendLine()

        sb.appendLine("""
            (define-private (check-timeout (delta uint))
                (>= (get-time) (+ (var-get last-progress) delta))
            )
        """.trimIndent())

        sb.appendLine("""
            (define-private (verify-commit (val (buff 128)) (salt (buff 32)) (comm (buff 32)))
                (is-eq (sha256 (concat val salt)) comm)
            )
        """.trimIndent())

        sb.appendLine("""
            (define-private (is-done (id uint))
                (default-to false (map-get? action-done id))
            )
        """.trimIndent())

        if (options.clarityVersion >= 4) {
            sb.appendLine("(define-private (get-contract-principal) (unwrap-panic (as-contract? () tx-sender)))")
        } else {
            sb.appendLine("(define-private (get-contract-principal) (as-contract tx-sender))")
        }
        sb.appendLine()
    }

    private fun generateRegistration() {
        sb.appendLine(";; Registration")
        protocol.roles.forEach { role ->
            val roleName = kebab(role.name)
            val joinDeposit = game.dag.deposit(role)
            val depositAmount = joinDeposit?.asInt() ?: 0

            sb.appendLine("(define-public (register-$roleName)")
            sb.appendLine("    (begin")
            sb.appendLine("        (asserts! (is-none (var-get role-$roleName)) ERR_ALREADY_INITIALIZED)")

            if (depositAmount > 0) {
                 // Use helper to get contract principal
                 sb.appendLine("        (try! (stx-transfer? u$depositAmount tx-sender (get-contract-principal)))")
                 sb.appendLine("        (var-set total-pot (+ (var-get total-pot) u$depositAmount))")
                 sb.appendLine("        (var-set deposit-$roleName u$depositAmount)")
            }

            sb.appendLine("        (var-set role-$roleName (some tx-sender))")
            sb.appendLine("        (if (is-eq (var-get first-dep-time) u0) (var-set first-dep-time (get-time)) true)")
            sb.appendLine("        (check-initialization)")
            sb.appendLine("        (ok true)")
            sb.appendLine("    )")
            sb.appendLine(")")
            sb.appendLine()
        }

        sb.appendLine("(define-private (check-initialization)")
        sb.append("    (if (and")
        protocol.roles.forEach { role ->
            sb.append(" (is-some (var-get role-${kebab(role.name)}))")
        }
        sb.append(")")
        sb.appendLine()
        sb.appendLine("        (begin")
        sb.appendLine("            (var-set initialized true)")
        sb.appendLine("            (var-set last-progress (get-time))")
        protocol.initialDone.forEach { actionId ->
            val uintId = actionIds[actionId]!!
            sb.appendLine("            (map-set action-done u$uintId true)")
        }
        sb.appendLine("        )")
        sb.appendLine("        true")
        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateCancel() {
        sb.appendLine(";; Cancel")
        sb.appendLine("(define-public (cancel-uninitialized)")
        sb.appendLine("    (begin")
        sb.appendLine("        (asserts! (not (var-get initialized)) ERR_ALREADY_INITIALIZED)")
        sb.appendLine("        (asserts! (> (var-get first-dep-time) u0) ERR_NOT_OPEN)")
        sb.appendLine("        (asserts! (>= (get-time) (+ (var-get first-dep-time) u${options.defaultTimeout})) ERR_TIMEOUT_NOT_READY)")

        protocol.roles.forEach { role ->
            val roleVar = "role-${kebab(role.name)}"
            val depVar = "deposit-${kebab(role.name)}"

            sb.appendLine("        (match (var-get $roleVar) r")
            sb.appendLine("            (let ((amt (var-get $depVar)))")
            sb.appendLine("                (if (> amt u0)")
            if (options.clarityVersion >= 4) {
                // Nested unwrap for Clarity 4: (as-contract? (stx-transfer?)) returns (response (response bool uint) uint)
                // We need 'bool' result for the match branch.
                sb.appendLine("                    (unwrap-panic (as-contract? ((with-stx amt)) (unwrap-panic (stx-transfer? amt tx-sender r))))")
            } else {
                sb.appendLine("                    (unwrap-panic (as-contract (stx-transfer? amt tx-sender r)))")
            }
            sb.appendLine("                    true")
            sb.appendLine("                )")
            sb.appendLine("            )")
            sb.appendLine("            true")
            sb.appendLine("        )")
        }

        sb.appendLine("        (var-set total-pot u0)")
        protocol.roles.forEach { role ->
            sb.appendLine("        (var-set role-${kebab(role.name)} none)")
            sb.appendLine("        (var-set deposit-${kebab(role.name)} u0)")
        }
        sb.appendLine("        (var-set first-dep-time u0)")
        sb.appendLine("        (ok true)")
        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateActions() {
        sb.appendLine(";; Actions")

        sortedActions.forEachIndexed { index, action ->
            if (action.id in protocol.initialDone) return@forEachIndexed

            val actionIdUint = index
            val actionName = "action-${kebab(action.owner.name)}-${action.id.second}"

            val funcParams = mutableListOf<String>()
            val paramChecks = mutableListOf<String>()
            val updates = mutableListOf<String>()

            val localParams = mutableMapOf<FieldRef, String>()

            action.params.forEach { param ->
                val type = toClarityType(param.type)
                localParams[FieldRef(action.owner, VarId(param.name))] = param.name
                if (param.isSalt) {
                    funcParams.add("(${param.name} $type)")
                    funcParams.add("(${param.name}-salt (buff 32))")
                } else {
                    if (action.type is ActionType.Commit) {
                        funcParams.add("(${param.name} (buff 32))")
                    } else {
                        funcParams.add("(${param.name} $type)")
                    }
                }
            }

            if (action.type is ActionType.Commit) {
                action.writes.forEachIndexed { i, write ->
                    val paramName = action.params[i].name
                    updates.add("(var-set commit-${kebab(write.name)} (some $paramName))")
                }
            } else if (action.type is ActionType.Reveal) {
                action.writes.forEachIndexed { i, write ->
                    val paramName = action.params[i].name
                    val saltName = "$paramName-salt"
                    paramChecks.add("""
                        (asserts! (verify-commit
                            (unwrap-panic (to-consensus-buff? $paramName))
                            $saltName
                            (unwrap-panic (var-get commit-${kebab(write.name)}))
                        ) ERR_COMMIT_MISMATCH)
                    """.trimIndent())
                    updates.add("(var-set var-${kebab(write.name)} $paramName)")
                }
            } else {
                action.writes.forEachIndexed { i, write ->
                    val paramName = action.params[i].name
                    updates.add("(var-set var-${kebab(write.name)} $paramName)")
                }
            }

            action.params.forEach { p ->
                if (p.type is Type.SetType && !(action.type is ActionType.Commit)) {
                     val setType = p.type as Type.SetType
                     val checks = setType.values.joinToString(" ") { "(is-eq ${p.name} $it)" }
                     paramChecks.add("(asserts! (or $checks) ERR_INVALID_PARAM)")
                }
            }

            sb.appendLine("(define-public ($actionName ${funcParams.joinToString(" ")} )")
            sb.appendLine("    (begin")
            sb.appendLine("        (asserts! (var-get initialized) ERR_NOT_INITIALIZED)")
            sb.appendLine("        (asserts! (not (var-get payoffs-distributed)) ERR_NOT_OPEN)")
            sb.appendLine("        (asserts! (is-eq (some tx-sender) (var-get role-${kebab(action.owner.name)})) ERR_WRONG_ROLE)")

            sb.appendLine("        (asserts! (not (is-done u$actionIdUint)) ERR_ACTION_ALREADY_DONE)")

            if (index > 0) {
                sb.appendLine("        (asserts! (is-done u${index - 1}) ERR_DEPENDENCY_NOT_MET)")
            }

            action.prereqs.forEach { prereq ->
                val pid = actionIds[prereq]!!
                if (pid != index - 1) {
                    sb.appendLine("        (asserts! (is-done u$pid) ERR_DEPENDENCY_NOT_MET)")
                }
            }

            if (action.guard != null) {
                sb.appendLine("        (asserts! ${translateExpr(action.guard, ::getFieldWriters, localParams)} ERR_GUARD_FAILED)")
            }

            paramChecks.forEach { sb.appendLine("        $it") }
            updates.forEach { sb.appendLine("        $it") }

            sb.appendLine("        (map-set action-done u$actionIdUint true)")
            sb.appendLine("        (var-set last-progress (get-time))")
            sb.appendLine("        (ok true)")
            sb.appendLine("    )")
            sb.appendLine(")")
            sb.appendLine()
        }
    }

    private fun generateFinalize() {
        sb.appendLine(";; Finalize")
        sb.appendLine("(define-public (finalize)")
        sb.appendLine("    (begin")
        sb.appendLine("        (asserts! (var-get initialized) ERR_NOT_INITIALIZED)")
        sb.appendLine("        (asserts! (not (var-get payoffs-distributed)) ERR_ALREADY_INITIALIZED)")

        val lastActionId = sortedActions.size - 1
        sb.appendLine("        (asserts! (is-done u$lastActionId) ERR_NOT_OPEN)")

        val payouts = protocol.payoffs.mapValues { (_, expr) ->
            val intExpr = translateExpr(expr, ::getFieldWriters)
            "(unwrap-panic (to-uint $intExpr))"
        }

        if (payouts.isNotEmpty()) {
            val sumExpr = payouts.values.reduce { acc, s -> "(+ $acc $s)" }
            sb.appendLine("        (asserts! (is-eq $sumExpr (var-get total-pot)) ERR_PAYOUT_TOO_HIGH)")
        }

        payouts.forEach { (role, exprStr) ->
            sb.appendLine("        (map-set claims (unwrap-panic (var-get role-${kebab(role.name)})) $exprStr)")
        }

        sb.appendLine("        (var-set payoffs-distributed true)")
        sb.appendLine("        (ok true)")
        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateTimeout() {
        sb.appendLine(";; Timeout")
        sb.appendLine("(define-public (timeout)")
        sb.appendLine("    (begin")
        sb.appendLine("        (asserts! (var-get initialized) ERR_NOT_INITIALIZED)")
        sb.appendLine("        (asserts! (not (var-get payoffs-distributed)) ERR_ALREADY_INITIALIZED)")
        sb.appendLine("        (asserts! (check-timeout u${options.defaultTimeout}) ERR_TIMEOUT_NOT_READY)")

        var expr = "(err ERR_NOT_OPEN)"

        val reversedActions = sortedActions.reversed()

        for (action in reversedActions) {
            val aid = actionIds[action.id]!!
            val prevSet = sortedActions.take(aid).map { it.id }.toSet()
            val payoff = protocol.abortPayoffs[prevSet]

            if (payoff != null) {
                val payBlock = StringBuilder()
                payBlock.append("(begin ")
                payoff.forEach { (role, amt) ->
                    if (amt > 0) {
                        payBlock.append("(map-set claims (unwrap-panic (var-get role-${kebab(role.name)})) u$amt) ")
                    }
                }
                payBlock.append("(var-set payoffs-distributed true) (ok true))")

                expr = "(if (not (is-done u$aid)) $payBlock $expr)"
            }
        }
        sb.appendLine("        $expr")

        sb.appendLine("    )")
        sb.appendLine(")")
        sb.appendLine()
    }

    private fun generateWithdraw() {
        sb.appendLine(";; Withdraw")
        sb.appendLine("(define-public (withdraw)")
        sb.appendLine("    (let (")
        sb.appendLine("        (recipient tx-sender)")
        sb.appendLine("        (amt (default-to u0 (map-get? claims recipient)))")
        sb.appendLine("    )")
        sb.appendLine("        (asserts! (> amt u0) ERR_NOTHING_TO_WITHDRAW)")
        sb.appendLine("        (map-set claims recipient u0)")

        if (options.clarityVersion >= 4) {
            sb.appendLine("        (try! (as-contract? ((with-stx amt)) (try! (stx-transfer? amt tx-sender recipient))))")
        } else {
            sb.appendLine("        (try! (as-contract (stx-transfer? amt tx-sender recipient)))")
        }

        sb.appendLine("        (ok amt)")
        sb.appendLine("    )")
        sb.appendLine(")")
    }

    // Utils
    private fun getFieldWriters(f: FieldRef): List<Int> {
        return fieldWriters[f] ?: emptyList()
    }

    private fun kebab(s: String): String = s.fold(StringBuilder()) { acc, c ->
        if (c.isUpperCase()) {
            if (acc.isNotEmpty()) acc.append('-')
            acc.append(c.lowercaseChar())
        } else {
            acc.append(c)
        }
    }.toString()

    private fun defaultInit(t: Type): String = when(t) {
        Type.IntType -> "0"
        Type.BoolType -> "false"
        is Type.SetType -> "${t.values.first()}"
    }

    private fun toClarityType(t: Type): String = when(t) {
        Type.IntType -> "int"
        Type.BoolType -> "bool"
        is Type.SetType -> "int"
    }
}

fun genClarity(game: GameIR, opt: ClarityOptions = ClarityOptions()): String {
    return ClarityBackend(game, opt).generate()
}
